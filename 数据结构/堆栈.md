<!-- GFM-TOC -->
* [堆](#堆)
* [栈和堆](#栈和堆)
* [栈溢出](#栈溢出)

<!-- GFM-TOC -->



# 堆

堆是一棵**完全二叉树**（如果一共有 h 层，那么 1~h-1 层均满，在第 h 层可能会连续缺失若干个右叶子）。

## 小根堆

**Min-heap**：父节点的值小于或等于子节点的值。

## 大根堆

**Max-heap**：父节点的值大于或等于子节点的值。

## 时间复杂度

堆的**初始化**，时间复杂度为O(n)。

在堆排序中一次进行堆的初始化操作，其时间复杂度为O(n)，n-1次进行堆的调整，每次调整的时间复杂度为O(logn)，  所以，**堆排序**的时间复杂度为O(nlogn)。

因为堆的每次**插入、删除**元素均需要重新调整堆，所以插入、删除元素的时间复杂度为**O(logn)**。



# 栈和堆

## 堆和栈的区别

- 栈是由高地址向低地址扩展；堆是由低地址向高地址扩展。
- 栈中内存是由 OS 自动申请和自动释放，存放着参数、局部变量等内存；堆中的内存需要手动申请和手动释放。
- 堆中频繁调用 malloc 和 free，可能由于操作不当产生**内存碎片**，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片。
- 堆的分配效率较低，而栈的分配效率较高。

## 栈的效率高

栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的**寄存器**存储栈的地址，压栈和入栈有专门的指令执行；

而堆是由 C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/内存管理.png" width="700px" />





# 栈溢出

栈溢出（ stack overflow ）指的是程序向栈中某个变量中**写入的字节数**超过了这个变量本身所**申请的字节数**，因而导致栈中与其相邻的变量的值被改变。

## 原因

1. **局部数组过大**。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间，二是改用动态分配，使用堆（heap）而不是栈（stack）。
2. **递归调用层次太多**。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。
3. **指针或数组越界**。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。

## 例子

```c++
#include <stdio.h>
#include <string.h>
int main(int argc, char* argv[]) 
{
    char buf[256];
    strcpy(buf,argv[1]);
    printf("Input:%s\n",buf);
    return 0;
}
```

上述代码中的 `strcpy(buf,argv[1])`;这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的。






