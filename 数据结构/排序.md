<!-- GFM-TOC -->
* [快排](#快排)
* [第k大的数](#第k大的数)
* [最大的k个数](#最大的k个数)
* [快排](#快排)
* [排序算法](#排序算法)
* [排序算法复杂度](#排序算法复杂度)
* [排序算法稳定性](#排序算法稳定性)


<!-- GFM-TOC -->



# 快排

## 流程

1、从数列中取出一个数作为基准数（枢轴，pivot）。 
2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，
   将小于等于基准数的元素都移至枢轴左边。
3、再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。

## 时间复杂度

快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*logN)。

假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历至少log(N+1)次，最多N次。

最少是log(N+1)次：快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的**深度至少是log(N+1)**。因此，快速排序的遍历次数最少是log(N+1)次。

最多是N次：这个应该非常简单，还是将快速排序看作一棵二叉树，它的**深度最大是N**。因此，快读排序的遍历次数最多是N次。

```c++
int partition(int arr[], int left, int right)  //找基准数 划分
{
    int i = left + 1 ;
    int j = right;
    int temp = arr[left];

    while(i <= j)
    {
        while (arr[i] < temp)
        {
            i++;
        }
        while (arr[j] > temp )
        {
            j--;
        }
        if (i < j)
            swap(arr[i++], arr[j--]);
        else i++;
    }
    swap(arr[j], arr[left]);
    return j;
}

void quick_sort(int arr[], int left, int right) 
{
    if (left > right)
        return;
    int j = partition(arr, left, right);
    quick_sort(arr, left, j - 1);
    quick_sort(arr, j + 1, right);
}
```



# 第k大的数

求从小到大排的第k个数。

（1）使用**快速排序**算法将数组按照从小到大排序，然后取第 k 个。其时间复杂度最快为O(n*logn)。

（2）使用堆排序，建立**最小堆**，然后删除堆顶元素并调整堆，直到获得第 k 个元素。堆初始化时间复杂度为O(n)，需要 k 次插入删除操作，每次是O(logn)，总的时间复杂度为 O(n+klogn)

（3）首先利用**哈希表**统计数组中个元素出现的次数，然后利用**计数排序**的思想，线性从小到大扫描过程中，前面有 k-1 个数则为第 k 大的数。（特别适合有相同元素时）





# 最大的k个数

有n个数，找出其中最大的k个数。

## 1、最小堆法

这是一种局部淘汰法。先读取前 K 个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的 K 个数。

堆插入删除复杂度为O(logk)，需要进行n次操作，其时间复杂度为 O(n*logk)。

## 2、直接排序

只适用于内存够的情况

当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前 K 个。



## 3、快速排序的变形

只使用于内存够的情况。

这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前 K 个最大的就行。

这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号 index 刚好等于 K，那么这个划分元以及它左边的数，刚好就是前 K 个最大的元素；如果 index > K，那么前 K 大的数据在 index 的左边，那么就继续递归的从 index-1 个数中进行一趟排序；如果 index< K，那么再从划分元的右边继续进行排序，直到找到序号 index 刚好等于 K 为止。再将前 K 个数进行排序后，返回 Top K 个元素。这种方法就避免了对除了 Top K 个元素以外的数据进行排序所带来的不必要的开销。



## 4、分治法

将全部数据分成 N 份，找到每份数据中最大的 K 个数。此时剩下 N\*K 个数据，如果内存不能容纳 N\*K 个数据，则再继续分治处理，分成 M份，找出每份数据中最大的 K 个数，如果 M*K 个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

## 5、Hash法

如果这些数据中有很多重复的数据，可以先通过 hash 法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。





# 快排

## 1、快排算法

根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。

稳定性：不稳定

平均时间复杂度：O(nlogn)

## 2、稳定排序

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

快排算法是不稳定的排序算法。

例如，待排序数组：int a[] ={1, 2, 2, 3, 4, 5, 6};

若选择 a[2]（即数组中的第二个 2）为枢轴，而把大于等于比较子的数均放置在大数数组中，则 a[1]（即数组中的第一个 2）会到 pivot 的右边， 那么数组中的两个 2 非原序。若选择 a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个 2顺序也非原序。

## 3、快排最差情况

在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况
就会在下面的情况下发生啦：

1. 数组已经是正序排过序的。 （每次最右边的那个元素被选为枢轴）
2. 数组已经是倒序排过序的。 （每次最左边的那个元素被选为枢轴）
3. 所有的元素都相同（1、2 的特殊情况）

因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。快速排序，在最坏情况退化为冒泡排序，需要比较 O(n2)次（n(n - 1)/2 次）。







# 排序算法

https://blog.csdn.net/yushiyi6453/article/details/76407640

## 1、冒泡排序

冒泡排序从小到大排序：一开始交换的区间为0~N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。然后将范围变为0~N-2，数组第二大的数会放在数组倒数第二的位置。依次进行整个交换过程，最后范围只剩一个数时数组即为有序。

## 2、选择排序

选择排序从小到大排序：一开始从0~n-1区间上选择一个最小值，将其放在位置0上，然后在1~n-1范围上选取最小值放在位置1上。重复过程直到剩下最后一个元素，数组即为有序。

## 3、插入排序

插入排序从小到大排序：首先位置1上的数和位置0上的数进行比较，如果位置1上的数大于位置0上的数，将位置0上的数向后移一位，将1插入到0位置，否则不处理。位置k上的数和之前的数依次进行比较，如果位置K上的数更大，将之前的数向后移位，最后将位置k上的数插入不满足条件点，反之不处理。

## 4、归并排序

归并排序从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。

## 5、快速排序

快速排序从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。

## 6、堆排序

堆排序从小到大排序：首先将数组元素建成大小为n的**大顶堆**，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。

## 7、希尔排序

希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1。步长选择是关键。

## 8、桶排序

核心思想是将要排序的数据分到几个有序的桶里，对每个桶内的数据进行快速排序。桶内排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

 桶排序的平均时间复杂度为线性的O(N+C)，其中M为桶的个数，C=N\*(logN-logM)。

## 9、计数排序

计数排序可以看作是桶排序的一种特殊情况。当要排序的数据所处的范围并不大时，比如最大值为 K，这时候，我们可以把数据分为 K 个桶，每个桶内的数据都是相同的，省掉了桶内排序的时间。

## 10、基数排序

是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数



# 排序算法复杂度

各个排序的时间复杂度、空间复杂度及稳定性如下：

| 排序算法   | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| ---------- | -------------- | -------------- | ---------- | -------- |
| 1冒泡排序  | O(n2)          | O(n2)          | O(1)       | 是       |
| 2选择排序  | O(n2)          | O(n2)          | O(1)       | 不是     |
| 3插入排序  | O(n2)          | O(n2)          | O(1)       | 是       |
| 4归并排序  | O(nlogn)       | O(nlogn)       | O(n)       | 是       |
| 5快速排序  | O(nlogn)       | O(n2)          | O(logn)    | 不是     |
| 6堆排序    | O(nlogn)       | O(nlogn)       | O(1)       | 不是     |
| 7希尔排序  | O(nlogn)       | O（n^s）       | O(1)       | 不是     |
| 8桶排序    | O(n+c)         |                | O(n+m)     | 是       |
| 9计数排序  | O(n+k)         | O(n+k)         | O(n+k)     | 是       |
| 10基数排序 | O(N∗M)         | O(N∗M)         | O(M)       | 是       |

时间复杂度

- 冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n2)（一遍找元素O(n)，一遍找位置O(n)）
- 快速、归并、希尔、堆排序基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）



# 排序算法稳定性

排序前后相同元素的**相对位置不变**，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

### 不稳定算法

“快希选堆”（快牺牲稳定性）：快速排序、希尔排序、选择排序、堆排序

### 稳定算法

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序







