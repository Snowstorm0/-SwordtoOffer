<!-- GFM-TOC -->

* [加密方法](#加密方法)
  * [1、单向加密](#1单向加密)
  * [2、对称加密](#2对称加密)
  * [3、非对称加密](#3非对称加密)
  * [4、算法结合](#4算法结合)
* [二、跨站请求伪造](#二跨站请求伪造)
* [三、SQL 注入攻击](#三sql-注入攻击)
* [四、拒绝服务攻击](#四拒绝服务攻击)
* [参考资料](#参考资料)

<!-- GFM-TOC -->



# 加密方法

**公钥加密**：通信双方在网络通信之前，需要先知道加解密算法和密钥。

**数字签名**：接收方接收到一个密文，用以确定是发送方本人发送的。

**消息认证**：接收方用以确认内容是否被修改过。



## 1、单向加密

单向加密又称为不可逆加密算法，其密钥是由**加密散列函数**生成的。单向散列函数一般用于产生消息摘要，密钥加密等，常见的有：

1. MD5（Message Digest Algorithm 5）：是 RSA 数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；
2. SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个 160 位的数值。其变种由 SHA192，SHA256，SHA384 等；
3. CRC-32，主要用于提供校验功能；

算法特征：

- 输入一样，输出必然相同；
- 雪崩效应，输入的微小改变，将会引起结果的巨大变化；
- 定长输出，无论原始数据多大，结果大小都是相同的；
- 不可逆，无法根据特征码还原原来的数据；

## 2、对称加密

采用单钥密码系统的加密方法，**同一个密钥**可以同时用作信息的**加密**和**解密**，这种加密方法称为对称加密，也称为单密钥加密。

特点：

1. 加密方和解密方使用同一个密钥；
2. 加密解密的**速度快**，适合数据比较长时的使用；
3. 密钥传输的过程**不安全**，且容易被破解，密钥管理也比较麻烦；

优点：

- 算法公开
- 计算量小
- 加密速度快
- 加密效率高

缺点：

- 对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥；
- 如果一方的秘钥被泄露，那么加密信息也就不安全了；
- 每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。

## 3、非对称加密

非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。非对称加密的主要功能就是加密和数字签名。

特征：

（1）秘钥对，公钥(public key)和私钥(secret key)

（2）主要功能：加密和签名

- 发送方用**接收方的公钥加密**，可以保证数据的机密性（**公钥加密**）。
- 发送方用**发送方的私钥加密**，可以实现身份验证（**数字签名**）。

（3）公钥加密（非对称加密）算法很少用来加密数据，速度太慢，通常用来实现身份验证。

常用的非对称加密算法

1. RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；既可以实现加密，又可以实现签名。
2. DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。
3. ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。

### 公钥加密

用公钥加密，再用私钥解密，这种情形一般用于公钥加密。

过程如下：

1. 首先接收方生成一对密钥，即私钥和公钥；
2. 然后，接收方将公钥发送给 发送方；
3. 发送方用收到的公钥对数据加密，再发送给接收方；
4. 接收方收到数据后，使用自己的私钥解密。

由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。

### 数字签名

用私钥加密，用公钥解密。常用于数字签名。

过程如下：

1. 首先发送方生成一对密钥，即私钥和公钥；
2. 然后，发送方将公钥发送给接收方；
3. 发送方用自己的私钥对数据加密，再发送给接收方；
4. 接收方收到数据后，使用发送方的公钥解密。

采用数字签名，只有发送方使用私钥签名得到的信息，才能用这个公钥来解，可以确认两点：

1. 保证信息是由发送者自己签名发送的。
2. 保证信息自签发后到收到为止未曾作过任何修改。



## 4、算法结合

公钥机制效率非常低，为了兼顾安全和效率，结合使用公钥算法和私钥算法：

1. 首先，发送方使用对称算法对原始信息进行加密。
2. 接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。
3. 接收方将公钥发送给发送方。
4. 发送方用公钥对对称算法的密钥进行加密，并发送给接收方。
5. 接收方用私钥进行解密得到对称算法的密钥。
6. 发送方再把已加密的原始信息发送给接收方。
7. 接收方使用对称算法的密钥进行解密。



# LRU缓存

LRU（最近最少使用，Least Recently Used）算法根据数据的历史访问记录来进行淘汰数据。其核心思想是：如果数据最近被访问过，那么将来被访问的几率也更高。

实现：使用一个链表保存缓存数据，将**新数据插入到头部**，每当缓存命中时，则将命中的数据移动到链表头部，当链表满的时候，将链表**尾部的数据丢弃**。



# 洗牌算法

## FY洗牌算法

Fisher-Yates Shuffle 算法。其基本思想就是从原始数组中**随机取一个之前没取过的数字**到新的数组中。

具体如下：

1. 初始化原始数组和新数组，原始数组长度为 n(已知)。
2. 从还没处理的数组（假如还剩 k 个）中，随机产生一个[0, k)之间的数字p（假设数组从 0 开始）。
3. 从剩下的 k 个数中把第 p 个数取出。
4. 重复步骤 2 和 3 直到数字全部取完。
5. 从步骤 3 取出的数字序列便是一个打乱了的数列。

时间复杂度为 O(n*n)，空间复杂度为 O(n)。

## KD洗牌算法

Knuth-Durstenfeld Shuffle 算法。在原始数组上对数字进行交互，省去了额外 O(n)的空间。该算法的基本思想和 FY 类似，每次从未处理的数据中随机取出一个数字，然后把该数字**放在数组的尾部**，即数组尾部存放的是已经处理过的数字。

算法步骤为：

1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；
2. 生成一个从 0 到 n - 1 的随机数 x；
3. 输出 arr 下标为 x 的数值，即为第一个随机数；
4. 将 arr 的尾元素和下标为 x 的元素互换；
5. 同 2，生成一个从 0 到 n - 2 的随机数 x；
6. 输出 arr 下标为 x 的数值，为第二个随机数；
7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；

如上，直到输出 m 个数为止。

时间复杂度为 O(n)，空间复杂度为 O(1)，缺点必须知道数组长度 n。





















































