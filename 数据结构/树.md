<!-- GFM-TOC -->
* [二叉搜索树](#二叉搜索树)

* [平衡二叉树](#平衡二叉树)

* [红黑树](#红黑树)

    * [变色](#变色)
    * [左旋](#左旋)
    * [右旋](#右旋)

* [B树](#B树)

* [B+树](#B+树)


<!-- GFM-TOC -->





# 二叉搜索树

Binary Search Tree，根节点大于左子树，小于右子树，利用二分法查找。查找的最大次数等于树的高度，平均时间复杂度为O(logn)。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/v2-a346782e1ad8ede7d328dddb8a7e76b4_r.jpg" width="300px" />



## 缺点

二叉搜索树存在**不平衡**的缺点，时间复杂度接近线性：

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/v2-38e1125c3caa7bc83723f70f28533638_r.jpg" width="300px" />



# 平衡二叉树

平衡二叉树又称为 AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且**左右子树高度之差的绝对值不超过 1**。以树中所有结点为根的树的左右子树高度之差的绝对值不超过 1。

将二叉树上结点的左子树深度减去右子树深度的值称为**平衡因子** BF，那么平衡二叉树上的所有结点的平衡因子只可能是 -1、0 和 1。

插入或删除节点时，需要利用左旋、右旋维持平衡。



# 红黑树

红黑树（Red–black tree）是在 AVL 树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/v2-a183459a6010189e8b2b9415d85e550e_r.jpg" width="600px" />

特点：

1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点都是黑色的空节点（NIL节点）。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了**logn的高度**，从而实现红黑树的**查找、插入、删除的时间复杂度最坏为O(log n)**。

在红-黑树中**插入的节点都是红色**的，因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小。原因是：插入黑色节点总会改变黑色高度（违背规则5），但是插入红色节点只有一半的机会会违背规则4。另外违背规则4比违背规则5要更容易修正。

红黑树的修正有变色、左旋和右旋。

## 变色

向原红黑树插入值为**21**的新节点，为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/v2-d4827e3f1f5f9556c01ea8ec6982775b_r.jpg" width="1000px" />

## 左旋

**逆时针**旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/v2-6cb033d91d7379b22d2dcd3d0f201c54_r.jpg" width="400px" />



## 右旋

**顺时针**旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/v2-24f4d2e75d0ccf54aeb6c2d5b36092f7_r.jpg" width="400px" />



## 和AVL的区别

AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的 rebalance，导致效率下降；

红黑树不是高度平衡的，保证最长路径不超过最短路径的二倍，因而近似平衡，算是一种折中，插入最多两次旋转，删除最多三次旋转。



# B树

B树和平衡二叉树稍有不同的是B树属于**多叉树**，又名平衡多路查找树，它的每一个节点最多包含**k个孩子**，k被称为B树的阶。k的大小取决于磁盘页的大小。

数据库索引存储在磁盘上，数据量比较大的时候，索引也比较大，使用索引查询的时候，不可能把整个索引全部加载到硬盘上，只能**逐一加载每一个磁盘页**，磁盘页对应着**树的节点**。最坏情况下，**磁盘IO的次数等于树的高度**。为了减少磁盘IO的次数，所以要把树变的“矮胖”一些，因此使用B树。B树是一种多路平衡查找树，

B-树在查询中的比较次数其实不比二叉查找树少，尤其当单一节点中的元素数量很多时。可是相比磁盘IO的速度，内存中的比较耗时几乎可以忽略。所以只要树的高度足够低，IO次数足够少，就可以提升查找性能。

B-树主要应用于文件系统以及部分数据库索引，比如非关系型数据库MongoDB。

规则：

1. 根结点至少有两个子女。
2. 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m。m/2向上取整。
3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m。
4. 所有的叶子结点都位于同一层。
5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

三阶B树，中间节点都包含2个元素和3个孩子：

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/6954572-aedb385199565f8e.jpg" width="400px" />

## 插入

插入4，自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是**拆分**节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/6954572-f58930efca86023d.jpg" width="400px" />

## 删除

删除11，自顶向下查找元素11的节点位置。删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为**左旋**）

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/6954572-4791013a1811b111.jpg" width="700px" />

# B+树

特征

1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存data，只用来key，**所有数据都保存在叶子节点**。
2. 所有的**叶子结点中包含了全部元素的信息**，且叶子结点本身依key的大小**自小而大顺序**链接。每一个叶子节点都带有**指向下一个节点的指针**，形成了一个有序链表。
3. 所有的**中间节点元素**都同时**存在于子节点**，在子节点元素中是**最大或最小元素**。
4. 根节点的最大元素也就等同于整个B+树的最大元素。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/1572424667-b86a0e427f204ca.jpg" width="500px" />

父节点也存在与子节点中，是最大或最小元素。根节点的最大元素（这里是15），也就等同于整个B+树的最大元素。以后无论插入删除多少元素，始终要保持最大。

**卫星数据**，指的是索引元素所指向的数据记录，比如数据库中的某一行。在B树中，无论中间节点还是叶子节点都带有卫星数据。而在B+树当中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

## 与B树的区别

首先，B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。这就意味着，数据量相同的情况下， B+树的结构比B树更加“**矮胖**”，因此查询时IO次数也更少。

其次，B+树的查询必须最终查找到叶子节点，而B树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此，B树的查找性能并不稳定（最好情况是只查根节点，最坏情况是査到叶子节点）。而B+树的每一次查找都是稳定的。

对于范围查询（查找一个范围内的数），B+树只需要在叶子节点的链表上通过链表指针遍历。

B+树相比B树的优势有三个：

1. 单一节点存储更多的元素，使得查询的**IO次数更少**。
2. 所有查询都要查找到叶子节点，查询性能**稳定**。
3. 所有叶子节点形成有序链表，便于**范围查询**。









# 哈夫曼编码

哈夫曼编码是**哈夫曼树**的一种应用。ASCII码是一种等长编码，会浪费空间。哈弗曼编码则是不等长编码。

两个原则：

1. 任何一个字符编码，都不是其他字符编码的前缀。
2. 信息编码的总长度最小。

编码步骤：

1. 将符号按概率从大到小排列
2. 给概率最小的两个，分配码位“0”，“1”，将这两个符号合并(概率合并)，形成新的符号集。
3. 重复1-2，当信源剩下两个符号时停止，从后往前写编码（可分离的异前置码）。

假如一段信息里只有A，B，C，D，E，F这6个字符，他们出现的次数依次是2次，3次，7次，9次，18次，25次，则编码过程如下：

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/哈夫曼编码.jpeg" width="300px" />

编码结果为：A（11100）、B（11101）、C（1111）、D（1110）、E（10）、F（0）。









