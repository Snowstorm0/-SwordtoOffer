# 1、完美匹配

## （1）暴力法

遍历  +   对每个遍历的数据进行对比

## （2）KMP匹配

KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释）：

假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失败时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失败字符所在位置 - 失败字符对应的next 值（next 数组的求解会在下文的[3.3.3节](http://blog.csdn.net/v_july_v/article/details/7041827t9)中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 很快，你也会意识到next 数组各值的含义：若k=next[j]，代表模式串P中当前字符之前的字符串中，最前面的k个字符和j之前的最后k个字符是一样的。

如果用数学公式来表示是这样的：

P[0 ~ k-1] == P[j-k ~ j-1]

此也意味着在某个字符匹配失败时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k > 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <cstdlib>
#include <sstream>
#include <cstring>
#include <vector>

using namespace std;

const int mn = 1e6 + 10;

int n, m;
int nx[mn];

void cal_next(int b[])
{
    memset(nx, 0, sizeof nx);
    nx[0] = -1;
    int k = -1;
    int j = 0;
    while (j < m)
    {
        if (k == -1 || b[j] == b[k])
        {
            j++; k++;
            nx[j] = k;
        }
        else
            k = nx[k];
    }
}

int KMP(int a[], int b[])
{
    cal_next(b);

    int i = 0, j = 0;
    while (i < n && j < m)
    {
        if (j == -1 || a[i] == b[j]) 
            i++, j++;
        else 
            j = nx[j];
    }
    if (j >= m) 
        return i - m + 1;
    else 
        return 0;

}

int a[mn], b[mn];
int c[mn], d[mn];
int A[mn], B[mn];

int main()
{
    cin >> m;
    for (int i = 0; i < m; i++) 
        scanf("%d", &a[i]);
    for (int i = 0; i < m; i++) 
        scanf("%d", &b[i]);
    for (int i = 0; i < m; i++)
        A[i] = a[i] * 6 + b[i];


    cin >> n;
    for (int i = 0; i < n; i++) 
        scanf("%d", &c[i]);
    for (int i = 0; i < n; i++) 
        scanf("%d", &d[i]);
    for (int i = 0; i < n; i++)
        B[i] = c[i] * 6 + d[i];
    
    cout << KMP(B, A) << endl;
    
    return 0;

}
```



# 2、最长水流长度

某点A为起点的最长水沟长度 lenA，先计算A的上下左右四个点B1、B2、B3、B4中比A低的点如B1、B2的水沟长度，计B1、B2为起点的最长水沟长度为lenB1、lenB2，则 **lenA = max(lenB1, lenB2) + 1**，如果四周没有比A低的点则 **lenA = 1**;

```c++
void DFS(int nowx, int nowy)
{
    if (dp[nowx][nowy]) 
        return;
    dp[nowx][nowy] = 1;
    for (int i = 0; i <= 3; i++) 
    {
        int tx = nowx + x[i];
        int ty = nowy + y[i];
        if (tx >= 1 && tx <= N&&ty >= 1 && ty <= M&&a[nowx][nowy]>a[tx][ty]) 
        {
            DFS(tx, ty);
            dp[nowx][nowy] = max(dp[nowx][nowy], dp[tx][ty] + 1);
        }
    }
    ans = max(ans, dp[nowx][nowy]);
}
int main()
{
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
            DFS(i, j);
    }

    return 0;
}
```



# 3、一棵树最大亦或路径

题意：给定一棵树，问最大亦或路径。

思路: 首先最大亦或，得需要用 01Trie来做，如果你不会，那么这题应该就不会了。（劝退）

1，先介绍一下什么是Trie字典树：给你一本字典，让你查里面是否有某个单词，比如‘bcd’，你应该会看是否有 'b' 开头的单词，然后 ‘bc’ ，然后看 ‘bcd’ 。 这个的话，想象一个树，从根往下，连起来就是这个单词。 我们把单词都插入这个树里，就形成了一颗字典树，如果查单词，那么就从根向下查即可。 

这个相比hash的好处：

（1）不会出现hash那样的差错。

（2）前缀重复的地方可以节省空间。

2，其次是要知道亦或的性质： a到b的亦或 = a到根的亦或XORb到根的亦或。 所以我们求出每个点到根的亦或值，假设现在的亦或为a[]。 现在就是要在这些a[]里面找两个数，使得他们的亦或最大。

3，知道的性质2，和字典树。 我们就可以着手处理此题了。不过我们现在不是找单词，而是找最大亦或，我们把a[]集合的数都变为2进制，按高位到地位一次插入树里，现在要在集合里面找最大亦或，等效于高位尽可能不一样。 所以得尽量走反向，即我如果是1，我就看儿子节点是否有0。这在query里面得到体现。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn=200010;

int Laxt[maxn],Next[maxn],To[maxn],cnt;
int W[maxn],ch[maxn*30][2],ans,node;
void add(int u,int v)
{
    Next[++cnt]=Laxt[u];
    Laxt[u]=cnt;
    To[cnt]=v;
}
void dfs(int u,int f)
{
    W[u]=W[f]^W[u];
    for(int i=Laxt[u];i;i=Next[i])
    {
        int v=To[i];
        if(To[i]==f) 
            continue;
        dfs(To[i],u);
    }
}
int query(int x)
{
    int now=0,res=0;
    for(int i=30;i>=0;i--)
    {
        int t=(x>>i)&1;
        if(ch[now][1-t]) 
            res+=(1<<i),now=ch[now][1-t];
        else 
            now=ch[now][t];
    }
    return res;
}
int insert(int x)
{
    int now=0;
    for(int i=30;i>=0;i--)
    {
        int t=(x>>i)&1;
        if(!ch[now][t])  
            ch[now][t]=++node;
        now=ch[now][t];
    }
}
int main()
{
    int N,id,x;
    scanf("%d",&N);
    for(int i=1;i<=N;i++)
    {
        scanf("%d",&id);
        scanf("%d",&W[id]);
        for(int j=1;j<=2;j++)
        {
           scanf("%d",&x);
           if(x!=-1)
           {
               add(id,x);
               add(x,id);
           }
        }
    }
    dfs(1,0);
    for(int i=1;i<=N;i++)
    {
        if(i>1) ans=max(ans,query(W[i]));
        insert(W[i]);
    }
    printf("%d\n",ans);
    return 0;
}

```













