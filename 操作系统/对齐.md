<!-- GFM-TOC -->

* [对齐原因](#对齐原因)
* [对齐规则](#对齐规则)
* [定义结构体对齐](#定义结构体对齐)

<!-- GFM-TOC -->





# 对齐原因

## 1、平台原因（移植原因）

不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处访问某些特定类型的数据，否则抛出硬件异常。

## 2、性能原因

**提高存取数据的速度**。为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。



# 对齐规则

## 1、数据成员

结构题(struct)或联合体(union)的数据成员的**对齐参数**为 `#pragma pack` 指定的**默认对齐参数**和这个数据成员**自身长度**中，比较小的那个。

第一个数据成员放在offset 为 0 的地方，以后结构体每个成员相对结构体首地址的偏移量(offset)是对齐参数的整数倍。如有需要在成员之间填充字节。

## 2、结构体(联合体)

结构体(联合体)本身也要进行对齐，对齐参数为 `#pragma pack` 指定的**默认对齐参数**和**结构体(联合体)最大数据成员长度**中，比较小的那个。

结构体变量所占空间的大小是对齐参数大小的整数倍。如有需要会在最后一个成员末尾填充字节。

## 3、结构体作为成员

如果一个结构里有某些结构体成员，则结构体成员要从其内部**最大元素大小的整数倍**地址开始存储。



# 定义结构体对齐

可以通过预编译命令 `#pragma pack(n)，n=1,2,4,8,16` 来改变这一系数，其中的 n 就是指定的“对齐系数”。

举例：

```c++
#pragma pack(2)
struct AA 
{
    int a; //长度 int=4 > 2 按 2 对齐；偏移量为 0；存放位置区间[0,1,2,3]
    char b; //长度 char=1 < 2 按 1 对齐；偏移量为 4；存放位置区间[4]; [5]空闲
    short c; //长度 short=2 = 2 按 2 对齐；偏移量要提升到 2 的倍数 6；存放位置区间[6,7]
    char d; //长度 char=1 < 2 按 1 对齐；偏移量为 7；存放位置区间[8]；共九个字节
};
#pragma pack()
```

