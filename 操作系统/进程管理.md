<!-- GFM-TOC -->

* [进程管理](#进程管理)
    * [SIGCHLD](#sigchld)
    * [fork](#fork)
    * [wait()](#wait)
    * [waitpid()](#waitpid)
    * [孤儿进程](#孤儿进程)
    * [僵尸进程](#僵尸进程)
* [进程与线程](#进程与线程)
* [fork和vfork](#fork和vfork)
* [写时复制](#写时复制)
* [进程状态的切换](#进程状态的切换)
* [进程调度算法](#进程调度算法)
    * [1. 批处理系统](#1-批处理系统)
    * [2. 交互式系统](#2-交互式系统)
    * [3. 实时系统](#3-实时系统)
* [进程同步](#进程同步)
    * [1. 临界区](#1-临界区)
    * [2. 同步与互斥](#2-同步与互斥)
    * [3. 信号量](#3-信号量)
    * [4. 管程](#4-管程)
* [经典同步问题](#经典同步问题)
    * [1. 哲学家进餐问题](#1-哲学家进餐问题)
    * [2. 读者-写者问题](#2-读者-写者问题)
* [进程通信](#进程通信)
    * [1. 无名管道pipe](#1无名管道pipe)
    * [2. 命名管道FIFO](#2命名管道FIFO)
    * [3. 消息队列](#3消息队列)
    * [4. 信号量](#4信号量)
    * [5. 共享存储](#5共享存储)
    * [6. 套接字](#6套接字)
* [线程通信](#线程通信)
    * [1. 临界区](#1临界区)
    * [2. 互斥量](#2互斥量)
    * [3. 信号量](#3信号量)
    * [4. 事件](#4事件)

<!-- GFM-TOC -->



# 进程管理

## SIGCHLD

SIGCHLD(sig child)：当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：

- 得到 **SIGCHLD 信号**；
- **waitpid() 或者 wait() 调用**会返回。

其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。

在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。

## fork

fork用于**创建**一个和当前进程映像一样的进程，可以通过 `fork( )`函数调用：

```c++
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

成功调用 `fork( )`会创建一个新的进程，它几乎与原进程一模一样，这两个进程都会继续运行。在子进程中，成功的 `fork( )`调用会返回 0。在父进程中 `fork( )`返回子进程的 pid。如果出现错误，`fork( )`返回一个负值。

最常见的 `fork( )`用法是创建一个新的进程，然后使用 `exec( )`**载入二进制映像**，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“**派生加执行**”的方式是很常见的。

现代的 Unix 系统采取了优化，例如 Linux，采用了**写时复制**的方法，而不是对父进程空间进程整体复制。

## wait()

```c
pid_t wait(int *status)
```

父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 **wait() 函数会销毁子进程并返回子进程的PID**。

如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD(e child)。

参数 status 用来保存被收集的**子进程退出时的一些状态**，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。

## waitpid()

```c
pid_t waitpid(pid_t pid, int *status, int options)
```

作用和 wait() 完全相同，但是多了两个可由用户控制的参数 **pid 和 options**。

pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。

options 参数主要有 **WNOHANG(w no hang，非阻塞)**和WUNTRACED(w untraced，暂停执行情况则马上返回) 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。

## 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

## 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么**子进程的进程描述符仍然保存在系统中**，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 **Z（zombie）**。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。



# 进程与线程

## 1. 进程

进程是**资源分配**的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/> </div><br>

## 2. 线程

线程是**CPU调度**的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/> </div><br>

## 3. 区别

### 1、拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

### 2、调度

线程是CPU调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

### 3、系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

### 4、通信方面

同一进程中的多个线程具有相同的地址空间，可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC (InterProcess Communication)。



# fork和vfork

## fork

fork用于**创建**一个和当前进程映像一样的进程，可以通过 `fork( )`函数调用：

```c++
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

成功调用 `fork( )`会创建一个新的进程，它几乎与原进程一模一样，这两个进程都会继续运行。在子进程中，成功的 `fork( )`调用会返回 0。在父进程中 `fork( )`返回子进程的 pid。如果出现错误，`fork( )`返回一个负值。

最常见的 `fork( )`用法是创建一个新的进程，然后使用 `exec( )`**载入二进制映像**，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“**派生加执行**”的方式是很常见的。

现代的 Unix 系统采取了优化，例如 Linux，采用了**写时复制**的方法，而不是对父进程空间进程整体复制。

## vfork

在实现写时复制之前，BSD 的开发者们在 3.0 的 BSD 系统中引入了 `vfork( )`系统调用。

```c++
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void);
```

除了子进程必须要立刻执行一次对 exec 的系统调用，或者调用`_exit( )`退出，对 `vfork( )`的成功调用所产生的结果和 `fork( )`是一样的。`vfork( )`会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，`vfork( )`避免了地址空间的按页复制。在这个过程中，父进程和子进程**共享**相同的地址空间和页表项。实际上 `vfork( )`只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。

即使增加了写时复制，`vfork( )`也要比 `fork( )`快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换 `fork( )`争论。实际上，直到 2.2.0 内核，`vfork( )`只是一个封装过的 `fork( )`。因为对 `vfork( )`的需求要小于 `fork( )`，所以 `vfork( )`的这种实现方式是可行的。

## 区别：

1. `fork( )`的子进程**拷贝**父进程的数据段和代码段；`vfork( )`的子进程与父进程**共享**数据段
2. `fork( )`的父子进程的执行次序不确定；`vfork( )`保证子进程先运行，在调用 exec 或 exit
   之前与父进程数据是共享的，在它调用 exec 或 exit 之后父进程才可能被调度运行。
3. `vfork( )`保证子进程先运行，在它调用 exec 或 exit 之后父进程才可能被调度运行。如
   果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。
4. 当需要改变共享数据段中变量的值，则拷贝父进程。

# 写时复制

Linux 采用了写时复制（Copy-On-Write）的方法：如果有某个进程要**读取**自己的那部分资源，不需要复制。如果一个进程要**写入**自己的那份资源，那么就会**复制**那份资源并提供给进程，同时其他的进程仍然共享那份没有修改过的资源。

在使用虚拟内存的情况下，写时复制是以**页**为基础进行的。在 `fork( )`调用结束后，父进程和子进程都相信它们有一个自己的**地址空间**，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。

实现：

与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个**缺页中断**，此时内核对该页进行一次透明复制，清除页面的 COW 属性，表示着它不再被共享。













# 进程状态的切换

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div><br>

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

# 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

## 1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.1 先来先服务 first-come first-serverd（FCFS）**  

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**  

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**  

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

## 2. 交互式系统

交互式系统有**大量的用户交互操作**，在该系统中调度算法的目标是**快速地进行响应**。

**2.1 时间片轮转**  

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div><br>

**2.2 优先级调度**  

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**  

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div><br>

## 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

# 进程同步

## 1. 临界区

对临界资源进行访问的那段**代码**称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```html
// entry section
// critical section;
// exit section
```

## 2. 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得**进程有一定的先后执行关系**。
- 互斥：多个进程在同一时刻只有一个进程能进入**临界区**。

## 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

-   **down**   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
-   **up**  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了   **互斥量（Mutex，mutual exclusive）**  ，0 表示临界区已经加锁，1 表示临界区解锁。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

<font size=3>   **使用信号量实现生产者-消费者问题**   </font> </br>

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

## 4. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```pascal
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
```

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了   **条件变量**   以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

<font size=3>  **使用管程实现生产者-消费者问题**  </font><br>

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

# 经典同步问题

生产者和消费者问题前面已经讨论过了。

## 1. 哲学家进餐问题

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。

```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

```c
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&mutex);
    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}

void eat(int i) {
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

## 2. 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```

# 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

进程间通信主要包括管道、系统 IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字 socket。

## 1、无名管道pipe

管道是通过调用 `pipe` 函数创建的，fd[0] 用于读，fd[1] 用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输），具有固定的读端和写端；
- 只能在父子进程或者兄弟进程中使用；
- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>

## 2、命名管道FIFO

**FIFO**(First In, First Out)，也称为**命名管道**，允许无亲缘关系进程间的通信。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO 常用于客户-服务器应用程序中，FIFO 用作**汇聚点**，在客户进程和服务器进程之间传递数据。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" width="500px"/> </div><br>

## 3、消息队列

消息队列，是**消息的链接表**，存放在内核中。一个消息队列由一个标识符（即队列 ID）来标记。 消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限的进程则可以从消息队列中读取信息；

相比于 FIFO，消息队列具有以下优点：

- 消息队列是面向记录的，其中的消息具有特定的**格式**以及特定的**优先级**。
- 消息队列可以**独立于读写进程**，进程终止时，消息队列及其内容并不会被删除。
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，消息不一定要以先进先出的次序读取，而不像 FIFO 那样只能默认地接收。

## 4、信号量

信号量（semaphore）是一个**计数器**，信号量用于实现进程间的**互斥与同步**，防止出现因多个程序同时访问一个共享资源而引发的一系列问题。

信号量可以通过生成并使用**令牌**来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。

特点：

1. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
2. 信号量基于操作系统的 **PV 操作**，程序对信号量的操作都是**原子操作**。
3. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
4. 支持信号量组

PV操作是一种实现进程互斥与同步的有效方法。PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。用一个**信号量**与一个**消息**联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。

## 信号 

信号（signal）是一种比较复杂的通信方式，用于通知接收进程**某个事件已经发生**。

## 5、共享存储

允许多个进程共享一个给定的存储区。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。

特点：

- 多个进程可以将同一个文件**映射**到它们的地址空间从而实现共享内存。
- 共享内存是**最快**的一种 IPC，因为进程是直接对内存进行存取，数据不需要在进程之间复制
- 因为多个进程可以同时操作，所以需要使用**信号量**用来同步对共享存储的访问。

## 6、套接字

socket 也是一种进程间通信机制，不止用于同一机器，也可用于**不同机器间的进程通信**。



# 线程通信

## 1、临界区

通过多线程的**串行化**来访问公共资源或一段代码，速度快，适合控制数据访问；

## 2、互斥量

互斥量 Synchronized/Lock：采用**互斥对象机制**，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

## 3、信号量

信号量 Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的**最大线程数目**。PV操作。

## 4、事件

事件(信号)，Wait/Notify：通过**通知操作**的方式来保持多线程同步。还可以方便的实现多线程优先级的比较操作。事件分为手动置位事件和自动置位事件。

事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示**事件有无触发**。

