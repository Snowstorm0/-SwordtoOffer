<!-- GFM-TOC -->

* [基本特征](#基本特征)
    * [1. 并发](#1-并发)
    * [2. 共享](#2-共享)
    * [3. 虚拟](#3-虚拟)
    * [4. 异步](#4-异步)
* [并发和并行](#并发和并行)
* [系统调用](#系统调用)
* [大内核和微内核](#大内核和微内核)
    * [1. 大内核](#1-大内核)
    * [2. 微内核](#2-微内核)
* [中断分类](#中断分类)
    * [1. 外中断](#1-外中断)
    * [2. 异常](#2-异常)
    * [3. 陷入](#3-陷入)
* [最大句柄数](#最大句柄数)
* [MySQL端口号](#MySQL端口号)

<!-- GFM-TOC -->

# 基本特征

## 1. 并发

并发是指宏观上在**一段时间**内能同时运行多个程序，而并行则指**同一时刻**能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

## 2. 共享

共享是指系统中的资源可以被多个**并发进程**共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

## 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 4. 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

# 并发和并行

## 并发

并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核 cpu 上的多任务。但是从微观上看两个程序的指令是**交织运行**的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能**提高效率**。

## 并行

并行（parallelism）：指严格物理意义上的**同时运行**，比如**多核 cpu**，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的 cpu 都是往多核方面发展。



# 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div><br>

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :---: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |

# 大内核和微内核

## 1. 大内核

大内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

## 2. 微内核

由于操作系统不断复杂，因此将一部分**操作系统功能**移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>

# 中断分类

## 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

## 2. 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

## 3. 陷入

在用户程序中使用系统调用。



# 最大句柄数

句柄就是个数字，一般和当前系统下的整数的位数一样，比如32bit系统下就是4个字节。**句柄是一个对象的唯一标示**，和对象一一对应。这个对象可以是一个块内存，一个资源，或者一个服务的context（如 socket，thread）等等。

最大句柄数就是可以同时打开的文件数。

linux 默认最大文件句柄数是 1024 个，在 linux 服务器文件并发量比较大的情况下，系统会报"too many open files"的错误。故在 linux 服务器高并发调优时，往往需要预先调优 Linux参数，修改 Linux 最大文件句柄数。

## 查看最大句柄数

首先查询 Linux 相关的参数：

```shell
ulimit -a
```

输出如下所示：

> core file size (blocks, -c) 0
> data seg size (kbytes, -d) unlimited
> scheduling priority (-e) 0
> file size (blocks, -f) unlimited
> pending signals (-i) 94739
> max locked memory (kbytes, -l) 64
> max memory size (kbytes, -m) unlimited
> open files (-n) 1024
>
> pipe size (512 bytes, -p) 8
> POSIX message queues (bytes, -q) 819200
> real-time priority (-r) 0
> stack size (kbytes, -s) 8192
> cpu time (seconds, -t) unlimited
> max user processes (-u) 94739
> virtual memory (kbytes, -v) unlimited
> file locks (-x) unlimited

其中，open files 就是最大文件句柄数，默认是 1024 个。

## 修改最大句柄数

有两种方法：

### 1、修改当前进程

`ulimit -n <可以同时打开的文件数>`，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个 shell 或者重新开启一个进程，参数还是之前的值），

修改 Linux 最大文件句柄数：

```shell
ulimit -n 2048
```

 将最大句柄数修改为 2048 个。

### 2、修改所有进程

修改 Linux 系统参数：

```shell
vi /etc/security/limits.conf 
```

添加以下内容：

```c++
soft nofile 65536
hard nofile 65536
```

将最大句柄数改为 65536。

修改以后保存，注销当前用户，重新登录，修改后的参数就生效了。



# MySQL端口号

## 查看端口号

使用命令：

```shell
show global variables like 'port';
```

查看端口号 ，mysql 的默认端口是 **3306**。

补充：

- sqlserver 默认端口号为：1433；
- oracle 默认端口号为：1521；
- DB2 默认端口号为：5000；
- PostgreSQL 默认端口号为：5432

## 修改端口号

修改端口号：

编辑`/etc/my.cnf` 文件，早期版本有可能是 my.conf 文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。



















