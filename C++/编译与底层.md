# 目录

<!-- GFM-TOC -->

* [源文件从文本到可执行文件](#源文件从文本到可执行文件)
* [include头文件](#include头文件)
* [malloc原理](#malloc原理)
* [new/delete与malloc/free](#new/delete与malloc/free)
* [内存管理](#内存管理)
  * [栈空间](#栈空间)
* [内存泄漏](#内存泄漏)
* [段错误](#段错误)
* [共享内存相关api](#共享内存相关api)
* [reactor模型](#reactor模型)
* [内存泄漏](#内存泄漏)
* [内存泄漏](#内存泄漏)
* [内存泄漏](#内存泄漏)
  * [栈空间](#栈空间)
  * [继承权限](#继承权限)
* [struct和class](#struct和class)
* [类内定义引用数据成员](#类内定义引用数据成员)

<!-- GFM-TOC -->



# 源文件从文本到可执行文件

对于 C++源文件，从文本到可执行文件一般需要四个过程：

1. **预处理**阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成**预编译文件**(.i)；
2. **编译**阶段：将经过预处理后的预编译文件转换成特定**汇编代码**，生成**汇编文件**(.s) 。
3. **汇编**阶段：将编译阶段生成的汇编文件转化成**机器码**，生成**可重定位目标文件**(.o)；
4. **链接**阶段：将多个**目标文件**及所需要的**库**连接成最终的**可执行目标文件**(.out)。

<img src="../0other/0/pics/编译过程.jpg" width="600px" />

源代码(.cpp) => 预处理(g++ -E -o) => 预编译文件(.i) => 编译器(g++ -S) => 汇编程序(.s) => 汇编器(as) => 可重定位目标程序(.o) => 链接器(1d) => 可执行目标程序(.out)

命令：

1. 预处理：g++ -E hello.cpp -o hello.i
2. 编译：g++ -S hello.i -o hello.s  // 运行到.s
3. 运行 g++ -C hello.cpp  // 直接运行到.o 





# include头文件

## Include 头文件的顺序

对于 include 的头文件来说，如果在文件 a.h 中声明一个在文件 b.h中定义的变量，而不引用 b.h。那么要在 a.cpp 文件中引用 b.h 文件，并且要先引用 b.h，后引用a.h，否则汇报变量类型未声明错误。

## 双引号和尖括号的区别

编译器预处理阶段查找头文件的**路径**不一样。

使用双引号包含的头文件，多为自己编写的头文件。查找头文件路径的顺序为：

1. **当前头文件目录**
2. **编译器设置**的头文件路径（编译器可使用-I 显式指定搜索路径）
3. 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH (c plus include path / c include path) 指定的头文件路径

使用尖括号包含的头文件，多为系统头文件，查找头文件的路径顺序为：

1. 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）
2. 系统变量 CPLUS_INCLUDE_PATH / C_INCLUDE_PATH (c plus include path / c include path) 指定的头文件路径



# malloc原理

Malloc 函数用于**动态分配内存**。为了减少内存碎片和系统调用的开销，malloc 其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc 采用隐式**链表结构**将堆区分成连续的、大小不一的**块**，包含已分配块和未分配块；同时 malloc 采用**显示链表**结构来管理所有的**空闲块**，即使用一个**双向链表将空闲块连接**起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行**内存合并**时，malloc 采用**边界标记法**，根据每个块的前后块是否已经分配来决定是否进行块合并。

Malloc 在申请内存时，一般会通过 brk 或者 mmap 系统调用进行申请。其中当申请内存小于128K 时，会使用系统函数 **brk** 在**堆区**中分配；而当申请内存大于 128K 时，会使用系统函数 **mmap**在**映射区**分配。



# new/delete与malloc/free

1、new/delete 是C++的操作符，可以重载，不需要头文件支持；而malloc/free是C语言的库函数，需要头文件库函数支持。

2、new做两件事，一是分配内存，二是调用类的**构造函数**；同样，delete会调用类的**析构函数**和释放内存。而malloc和free只是分配和释放内存，必须指明申请内存空间的大小，不会调用构造函数和析构函数。

3、new建立的是一个对象，返回的是指向对象的指针，如果分配失败了会抛出 `std::bad_alloc`的异常；而malloc分配的是一块内存，返回的是无类型指针 void * ，因此 malloc 的返回值一般都需要进行类型转化，失败了会返回 NULL。

4、new 分配内存按照数据类型进行分配；malloc 分配内存按照指定的大小分配，分配的内存不够的时候，可以用 realloc 扩容。

5、new建立的对象可以用**成员函数访问**，不要直接访问它的地址空间；malloc分配的是一块内存区域，用**指针访问**，可以在里面移动指针。

6、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用 delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而 malloc 则只能 sizeof(int) * n。

## realloc 扩容

1.如果当前**连续内存块**足够 realloc 的话，只是将p所指向的空间扩大，并返回p的指针地址。 这个时候 q 和 p 指向的地址是一样的。

2.如果当前连续内存块不够长度，再找一个足够长的地方，分配一块新的内存q，并将 p指向的内容 copy到 q，返回 q。并将p所指向的内存空间删除。

```c++
char* p = malloc(1024);
char* q = realloc(p,2048);
```



# 内存管理

在 C++中，虚拟内存分为代码段、数据段、BSS 段、堆区、文件映射区以及栈区六部分。

1.**栈(stack)**：程序**自动分配**，使用栈空间存储函数的返回地址、参数、局部变量、返回值。

2.**堆(heap)**：

- **堆**：调用`malloc` 在堆区动态分配内存，调用 `free` 来手动释放。堆是**操作系统所维护**的一块特殊内存，它提供了动态分配的功能。
- **自由存储区**：由`new` 分配内存，用来 `delete` 手动释放。和堆类似，通过`new`来申请的内存区域可称为自由存储区。

3.**静态/全局区**：在 C++ 里面没有区分bss和data。

- **bss段**：存储**未初始化**的全局变量和静态变量（局部+全局），以及所有被**初始化为0**的全局变量和静态变量，Block Started by Symbol。
- **data段**：存储程序中**已初始化**的全局变量和静态变量。

4.**代码区**（code segment 或 text segment）：

- **代码段**：存放函数体的二进制代码，**text**段。
- **常量区**：只读数据，比如字符串常量，程序结束时由系统释放。**rodata段**，read only。

5.**映射区**：memory mapping segment，存储**动态链接库**等文件映射、申请大内存（malloc 时调用 mmap 函数）

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/内存管理.png" width="700px" />



32bitCPU 可寻址 4G 线性空间，每个进程都有各自独立的 4G 逻辑地址，其中 0~3G 是**用户态**空间，3~4G 是**内核**空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

## 栈空间

C++函数栈空间的最大值默认是 1M，不过可以调整。



# 内存泄漏

内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

## 分类：

### 1.堆内存泄漏（Heap leak）

对内存指的是程序运行中根据需要分配通过 **malloc/new** 等从堆中分配的一块内存，再是完成后必须通过调用对应的 **free/delete** 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生 Heap Leak。

解决办法：为了判断内存是否泄露，我们一方面可以使用 linux 环境下的**内存泄漏检查工具 Valgrind**，另一方面我们在写代码时可以添加内存申请和释放的**统计功能**，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

### 2.系统资源泄露（Resource Leak）

主要指程序使用**系统分配的资源**比如 bitmap，handle，socket 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

### 3.没有将基类的析构函数定义为虚函数

当基类指针指向子类对象时，如果基类的析构函数不是 virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。



# 段错误

段错误通常发生在**访问非法内存**地址的时候，具体来说分为以下几种情况：

1. 使用野指针
2. 试图修改字符串常量的内容

野指针就是指向一个**已删除的对象**或者**未申请访问受限内存区域**的指针







# 共享内存相关api

Linux 允许不同进程访问同一个逻辑内存，提供了一组 API，头文件在 sys/shm.h 中。

## 1.新建共享内存shmget

```c++
int shmget(key_t key,size_t size,int shmflg);
```

- key：共享内存键值，可以理解为共享内存的唯一性标记。
- size：共享内存大小
- shmflag：创建进程和其他进程的读写权限标识。
- 返回值：相应的共享内存标识符，失败返回-1

## 2.连接共享内存到当前进程的地址空间shmat

```c++
void *shmat(int shm_id,const void *shm_addr,int shmflg);
```

- shm_id：共享内存标识符
- shm_addr：指定共享内存连接到当前进程的地址，通常为 0，表示由系统来选择。
- shmflg：标志位
- 返回值：指向共享内存第一个字节的指针，失败返回-1

## 3.当前进程分离共享内存shmdt

```c++
int shmdt(const void *shmaddr);
```

## 4.控制共享内存shmctl

和信号量的 semctl 函数类似，控制共享内存

```c++
int shmctl(int shm_id,int command,struct shmid_ds *buf);
```

- shm_id：共享内存标识符
- command: 有三个值
- IPC_STAT:获取共享内存的状态，把共享内存的 shmid_ds 结构复制到 buf 中。
- IPC_SET:设置共享内存的状态，把 buf 复制到共享内存的 shmid_ds 结构。
- IPC_RMID:删除共享内存
- buf：共享内存管理结构体。




# reactor模型

reactor 模型要求**主线程只负责监听文件描述上是否有事件发生**，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/reactor模型.png" width="700px" />

1.Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer 等。由于 Reactor 模式一般使用在网络编程中，因而这里一般指 Socket Handle，即一个网络连接。

2.Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的 Handle 中的事件到来，如果阻塞等待返回，即表示在返回的 Handle 中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的 select 来实现。

3.Initiation Dispatcher：用于管理 Event Handler，即 EventHandler 的容器，用以注册、移除 EventHandler 等；另外，它还作为 Reactor 模式的入口调用 Synchronous Event Demultiplexer 的 select 方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的 Handle 将其分发给对应的 Event Handler 处理，即回调 EventHandler 中的 handle_event()方法。

4.Event Handler：定义事件处理方法：handle_event()，以供 InitiationDispatcher 回调使用。

5.Concrete Event Handler：事件 EventHandler 接口，实现特定事件处理逻辑。









































