# 目录

<!-- GFM-TOC -->

* [源文件从文本到可执行文件](#源文件从文本到可执行文件)
* [include头文件](#include头文件)
* [malloc原理](#malloc原理)
* [内存管理](#内存管理)
  * [栈空间](#栈空间)
* [内存泄漏](#内存泄漏)
* [段错误](#段错误)
* [内存泄漏](#内存泄漏)
* [内存泄漏](#内存泄漏)
* [内存泄漏](#内存泄漏)
* [内存泄漏](#内存泄漏)
* [内存泄漏](#内存泄漏)
  * [栈空间](#栈空间)
  * [继承权限](#继承权限)
* [struct和class](#struct和class)
* [类内定义引用数据成员](#类内定义引用数据成员)

<!-- GFM-TOC -->



# 源文件从文本到可执行文件

对于 C++源文件，从文本到可执行文件一般需要四个过程：

1. 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
2. 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
3. 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
4. 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

<img src="../0other/0/pics/编译过程.jpg" width="600px" />

源代码(.cpp) => 预处理(g++ -E) => 修改了的源代码(.i) => 编译器(g++ -S) => 汇编程序(.s) => 汇编器(as) => 可重定位目标程序(.o ) => 链接器(1d) => 可执行目标程序(.out)

命令：

1. 预处理：g++ -E hello.cpp -o hello.i
2. 编译：g++ -S hello.i -o hello.s  // 运行到.s
3. 运行 g++ -C hello.cpp  // 直接运行到.o 







# include头文件

## Include 头文件的顺序

对于 include 的头文件来说，如果在文件 a.h 中声明一个在文件 b.h中定义的变量，而不引用 b.h。那么要在 a.cpp 文件中引用 b.h 文件，并且要先引用 b.h，后引用a.h,否则汇报变量类型未声明错误。

## 双引号和尖括号的区别

编译器预处理阶段查找头文件的路径不一样。

对于使用双引号包含的头文件，查找头文件路径的顺序为：

1. 当前头文件目录
2. 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）
3. 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

对于使用尖括号包含的头文件，查找头文件的路径顺序为：

1. 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）
2. 系统变量 CPLUS_INCLUDE_PATH / C_INCLUDE_PATH 指定的头文件路径



# malloc原理

Malloc 函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc 其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc 采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时 malloc 采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc 采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。

Malloc 在申请内存时，一般会通过 brk 或者 mmap 系统调用进行申请。其中当申请内存小于128K 时，会使用系统函数 brk 在堆区中分配；而当申请内存大于 128K 时，会使用系统函数 mmap在映射区分配。





# 内存管理

在 C++中，虚拟内存分为代码段、数据段、BSS 段、堆区、文件映射区以及栈区六部分。

1.**栈(stack)**：程序**自动分配**，使用栈空间存储函数的返回地址、参数、局部变量、返回值。

2.**堆(heap)**：

- **堆**：调用`malloc` 在堆区动态分配内存，调用 `free` 来手动释放。堆是**操作系统所维护**的一块特殊内存，它提供了动态分配的功能。
- **自由存储区**：由`new` 分配内存，用来 `delete` 手动释放。和堆类似，通过`new`来申请的内存区域可称为自由存储区。

3.**静态/全局区**：在 C++ 里面没有区分bss和data。

- **bss段**：存储**未初始化**的全局变量和静态变量（局部+全局），以及所有被**初始化为0**的全局变量和静态变量，Block Started by Symbol。
- **data段**：存储程序中**已初始化**的全局变量和静态变量。

4.**代码区**（code segment 或 text segment）：

- **代码段**：存放函数体的二进制代码，**text**段。
- **常量区**：只读数据，比如字符串常量，程序结束时由系统释放。**rodata段**，read only。

<img src="E:/0OneDrive/OneDrive/Work/CSNote/0other/0/pics/image-20200805093916697.png" width="700px" />





32bitCPU 可寻址 4G 线性空间，每个进程都有各自独立的 4G 逻辑地址，其中 0~3G 是**用户态**空间，3~4G 是**内核**空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

**映射区**：memory mapping segment，存储动态链接库等文件映射、申请大内存（malloc 时调用 mmap 函数）

## 栈空间

C++函数栈空间的最大值默认是 1M，不过可以调整。





# 内存泄漏

内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用 linux 环境下的**内存泄漏检查工具 Valgrind**，另一方面我们在写代码时可以添加内存申请和释放的**统计功能**，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

# 段错误

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：

1. 使用野指针
2. 试图修改字符串常量的内容













































