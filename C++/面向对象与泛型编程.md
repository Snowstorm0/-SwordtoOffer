<!-- GFM-TOC -->

* [引用折叠](#引用折叠)
* [左值和右值](#左值和右值)
* [右值引用](#右值引用)
  * [1移动语意](#1移动语意)
  * [2完美转发](#2完美转发)
* [析构函数](#析构函数)
  * [类析构顺序](#类析构顺序)
* [虚函数](#虚函数)
  * [1多态和虚函数](#1多态和虚函数)
  * [2析构函数和虚函数](#2析构函数和虚函数)
  * [3静态函数和虚函数](#3静态函数和虚函数)
* [可变参数模板](#可变参数模板)

<!-- GFM-TOC -->







# 左值和右值

## 概念

1. 左值(lvalue)：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的**持久对象**。
2. 右值(rvalue)：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的**临时对象**。右值包括**纯右值**和**将亡值**，纯右值主要包括**常量**，将亡值主要指**临时变量**，被const修饰的变量也是右值，只能读不能写。

## **左值**

描述：能够用&取地址、或具名对象/变量， 一般指表达式结束后依然存在的**持久对象**。

举例：

- 函数名和变量名（实际上是函数指针和具名变量，具名变量如std::cin、std::endl等）、
- 返回左值引用的函数调用、前置自增/自减运算符连接的表达式++i/--i、
- 由赋值运算符或复合赋值运算符连接的表达式(a=b、a+=b、a%=b）、
- 解引用表达式*p、
- 字符串字面值"abc"等。

## **纯右值**

满足下列条件之一：

- 本身就是赤裸裸的、纯粹的**字面值**，如3、false（字符串字面值例外，是左值）；
- 求值结果相当于字面值或是一个不具名的**临时对象**。

举例：

- 除字符串字面值以外的字面值；
- 返回非引用类型的函数调用；
- 后置自增/自减运算符连接的表达式i++/i--；
- 算术表达式（a+b、a&b、a<<b）、逻辑表达式（a&&b、a||b、~a）、比较表达式（a==b、a>=b、a<b）；
- 取地址表达式（&a）等。



## **将亡值**

“将亡值”概念的产生，是由右值引用的产生而引起的。将亡值表达式：

- **返回右值引用的函数**的调用表达式
- **转换为右值引用的函数**的调用表达式

上面两种表达式的结果都是**不具名的右值引用（是右值）**。在C++11中，我们用左值去初始化一个对象或为一个已有对象赋值时，会调用**拷贝构造函数**或**拷贝赋值运算符**来拷贝new出来的对象，而当我们用一个右值（纯右值和将亡值）来初始化或赋值时，会调用**移动构造函数**或**移动赋值运算符**来移动资源，从而避免拷贝，提高效率。

当该右值完成初始化或赋值的任务时，它的资源已经移动给了被初始化者或被赋值者，同时该右值也将会马上被销毁（析构）。即当一个右值准备完成初始化或赋值任务时，它已经“将亡”了。

举例来说，`std::move()`、`static_cast()`这两个函数常用来将左值强制转换成右值，从而使拷贝变成移动，提高效率。



## 区别

区别：

1. 左值可以**寻址**，而右值不可以。
2. 左值可以被**赋值**，右值不可以被赋值，可以用来给左值赋值。
3. 左值**可变**，右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。
4. 当对象被用作左值的时候，用的是对象的在内存中的**位置**；当一个对象被用作右值的时候，用的是对象的值。

下面从上面的例子中选取若干典型详细说明左值和纯右值的判断。

**（1）++i是左值，i++是右值**

`++i`对i加1后再赋给i，最终的返回值就是i，所以，++i的结果是具名的，名字就是i；而对于`i++`而言，是先对i进行一次拷贝，将得到的副本作为返回结果，然后再对i加1，由于`i++`的结果是对i加1前i的一份拷贝，所以它是不具名的。

**（2）解引用表达式\*p是左值，取地址表达式&a是纯右值**

`&(*p)`一定是正确的，因为`*p`得到的是p指向的**实体**，`&(*p)`得到的就是这一实体的地址，正是p的值。由于`&(*p)`的正确，所以`*p`是左值。而对`&a`而言，得到的是a的地址，相当于unsigned int型的**字面值**，所以是纯右值。

**（3）a+b、a&&b、a==b都是纯右值**

`a+b`得到的是不具名的临时对象，而`a&&b`和`a==b`的结果非true即false，相当于字面值。

**（4）字符串字面值是左值。**

不是所有的字面值都是纯右值，字符串字面值是唯一例外。 早期C++将字符串字面值实现为char型数组，实实在在地为**每个字符都分配了空间**并且允许程序员对其进行操作，所以类似

```c++
cout << &("abc") << endl; //可以直接对字符串取地址&
char *p_char = "abc";  //注意不是char *p_char=&("abc");
```

这样的代码都是可以编译通过的。 注意上面代码中的注释，"abc"可以直接初始化指针 p_char，p_char 的值为字符串"abc"的首字符a的地址。

**（5）具名的右值引用是左值，不具名的右值引用是右值。**

```c++
struct X {};
X a;
X&& b = static_cast<X&&>(a);
X&& c = std::move(a);
// static_cast<X&&>(a) 和 std::move(a) 是不具名右值引用，是右值
// b 和 c 是具名右值引用，是左值

X& d = a;
X& e = b; //左值引用d和e只能绑定左值（包括普通左值a、具名右值引用b）

X&& h = X();//右值引用b、c、h只能绑定右值（包括不具名右值引用std::move(a)，临时对象X()）

const X& f = c;
const X& g = X();//const左值引用f和g可以绑定左值（右值引用c），也可以绑定右值（临时对象X()）
```



# 右值引用

普通引用称为左值引用(lvalue reference)，右值引用(rvalue reference)是 C++11 中引入的新特性 , 使用的符号是`&&`。右值引用实质上就是将不具名变量取了个别名，**具名右值引用本质是左值**。

左值引用只能绑定左值，右值引用只能绑定右值，否则编译就会失败。const左值引用可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，const左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。

```c++
int& a = 1; //编译错误! 1是右值，不能够使用左值引用
int&& a = 1; //正确，右值引用实质上就是将不具名(匿名)变量取了个别名
int b = 1;
int && c = b; //编译错误！ 不能将一个左值复制给一个右值引用
int && c = std::move(b);  //正确，使用move移动语意，转换左值为右值引用

class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
A && a = getTemp();   //getTemp()的返回值是右值（临时变量）
```

`getTemp()`返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量）。而通过右值引用，其生命期将与右值引用类型变量`a`的生命期一样，只要`a`还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字。

右值引用实现了**移动语义**和**完美转发**。使用：

`std::move(a) `将左值 a 转化为右值；

`std::forward(a)` 将右值引用 a 转化为右值。

## 1、移动语意

移动语意(`std::move`)，可以将左值转化为右值引用。消除**两个对象交互**时不必要的对象拷贝，节省运算存储资源，提高效率。

对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝。

```c++
class myVector 
{
    int size;
    double* array;
public:
    // 拷贝构造函数（深拷贝）
    myVector(const myVector& rhs) 
    {  
        size = rhs.size; 
        array = new double[size];
        for (int i=0; i<size; i++) 
            array[i] = rhs.array[i]; 
	}
};

myVector createMyVector {... }// 此函数返回值是一个 MyVector
int main() 
{
	myVector a = createMyVector(); 
    // createMyVector()返回临时变量、赋值给a 这两个过程都会调用拷贝构造函数
}
```

解决方法, 添加一个移动构造函数，那么，`myVector a = createMyVector()`就不会调用拷贝构造函数，而会调用移动构造函数。

```c++
myVector(myVector&& rhs) // 移动构造函数
{  
    size = rhs.size;  //将rhs.size和rhs.array的值给了size和array，不需要分配、释放内存
    array = rhs.array;
    rhs.size = 0; 
    rhs.array = nullptr;
}
```

## 2、完美转发

Perfect Forwarding，即完美转发，就是在参数传递过程中，值和属性（**左值／右值**）都不能改变，而不产生额外的开销。C++11是通过**引用折叠**结合新的**模板推导规则**来实现的完美转发。

### 引用折叠

引用折叠（reference collapsing），即创建**引用的引用**时（如模板参数、类型别名）会造成引用折叠，折叠规则如下（定义中出现了左值引用就折叠为左值引用）：

- T& & => T&
- T& && => T&
- T&& & => T&
- T&& && => T&&

因此，我们将转发函数和目标函数的参数都设置为右值引用类型。当传入一个左值引用时，经过引用折叠变为左值引用；当传入一个右值引用时，经过引用折叠变为右值引用。

### 模板推导

模板函数推导：当转发函数的实参是类型X的一个**左值引用**，那么模板参数被推导为**X&**类型；当转发函数的实参是类型X的一个**右值引用**，那么模板的参数被推导为**X&&**（转发引用）类型。我们不仅在参数部分使用了T&&这样的标识，在目标函数传参的强制类型转换中也使用了这样的形式。这个标识不是右值引用，它有专用的名字为转发引用（forwarding reference）。

### forword

 `std::forward`是在代码实现过程中，保持**实参**的原有的引用类型（左引用或者右引用类型）。不管传入的实参是左值还是右值，因为参数在函数内部有了名字，所以在函数内部就都变成了左值了。使用`std::forward()`函数，变量的右值属性将得到保留，实现如下：

```c++
template<class T>
T&& forward(typename remove_reference<T>::type& arg) 
{
  return static_cast<T&&>(arg);
}
```

参数转发：

```c++
class myVector {...} 
myVector createMyVector {... /*返回值是一个 MyVector*/}

void foo(myVector& v) {}
void foo(myVector&& v) {}

template<typename T>  // 参数转发
void relay(T arg) 
{
	foo(arg);
}
int main() 
{
	myVector reusable= reateMyVector();
	relay(reusable); // 拷贝构造函数
	relay(createMyVector()); // 移动构造函数
}
```

此时定义了的两个 `foo`只有 `foo(myVector& v)` 会被调用 ，因为右值引用 `myVector&& v`是个左值。

所以，我们需要改写上文的 relay 函数，借助 `std::forward`：

```c++
template<typename T>
void relay(T&& arg) 
{
    foo(std::forward<T>(arg));
}
```

于是就有：`relay(reusable)` 调用 `foo(myVector&)`；`relay(createMyVector()) `调用 `foo(myVector&&)`。实现完美转发。



# 析构函数

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如`~stud( )`，以区别于构造函数。它**不能带任何参数，也没有返回值**（包括 void 类型）。只能有一个析构函数，**不能重载**。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

## 类析构顺序

1. 派生类本身的析构函数
2. 对象成员析构函数
3. 基类析构函数

因为析构函数没有参数，所以包含成员对象的类的析构函数形式上并无特殊之处。但在撤销该类对象的时候，会首先调用自己的析构函数，再调用成员对象的析构函数，调用次序与初始化时的次序相反。



# 虚函数

C++使用函数继承的方法快速实现开发，而为了满足多态与泛型编程这一性质，C++允许用户使用虚函数 **(virtual function)** 来完成 **运行时决议** 这一操作，这与一般的 **编译时决定**有着本质的区别。

当一个类中包含被virtual 关键字修饰的成员函数时，该成员函数就成为了一个**虚函数**。第一个含有虚函数的类所实例化出来的对象都拥有同一个**虚函数表**，在对象中含有一个**虚函数指针 *_vptr**，该指针指向该类的虚函数表，虚函数表保存的是**类中虚函数的地址**（一个类可能有多个虚函数），实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，我们就说这两个类构成**多态**，此时会将其继承到的**虚函数表中的地址替换为重新写的函数地址**。从而基类与子类调用同名的虚函数时，所调用的就不是同一个函数，从而体现了多态和虚函数表的作用。使用了虚函数，会增加访问内存开销，降低效率。

##  1多态和虚函数

多态的实现主要分为**静态多态**和**动态多态**，**静态多态主要是重载**，在**编译的时候就已经确定**；**动态多态是用虚函数**机制实现的，在**运行期间动态绑定**。例如：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中**重写**了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了 virtual 关键字的函数，在子类中重写时候不需要加 virtual也是虚函数。

## 2析构函数和虚函数

析构函数必须是虚函数，因为将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用基类指针指向该子类对象`TestFather* p = new TestChild()`，**释放基类指针时可以释放掉子类的空间**，防止内存泄漏。否则直接给编译器一个基类的指针，delete的时候，编译器一看是基类的析构函数，直接调用基类析构函数，而没有析构子类。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的析构函数不是虚函数，而是只有当需要当作**父类**时，**设置虚函数**。

## 3静态函数和虚函数

静态函数是用**static**修饰的函数，限定在本源码文件中使用，不能被本源码文件以外的代码文件调用。 普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。

静态函数在**编译**的时候就已经确定运行时机，虚函数在**运行**的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。

**区别**：我们知道类的静态函数是没有this指针的，调用它时不需要创建对象，通过：类名 ：：函数名（参数）的形式直接调用。静态函数只有**唯一的**一份，因此它的**地址是固定不变的**， 所以编译的时候但凡遇到调用该静态函数的时候就知道调用的是哪一个函数，因此说**静态函数在编译的时候就已经确定运行时机。** 而虚函数则不然，看下面的代码：

```c++
class A
{
	public: 
	virtual void fun()
    {
        cout<<"i am A <<endl;
    }
}
class B: public A
{
	public:
	virtual  void  fun()
	{
        cout<<"I  am  B" <<endl;
    }
};
int main()
{
	A a ;
	B b;
	A*  pb = &b;
	pb->fun();
	return 0; 
}
```

类A与类B构成多态，创建了 A类指针pb指向 B类对象，当程序编译的时候只对语法等进行检测，该语句没有什么问题，但是编译器此时无法确定调用的是哪一个 fun() 函数，因为类A类B中都含有fun函数，因此只能是在程序运行的时候通过 pb指针查看对象的虚函数表（访问虚函数表就是所谓的访问内存）才能确定该函数的地址，即确定调用的是哪一个函数。这就解释了所说的“**虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。**”





# 可变参数模板

C++11 的可变参数模板，对参数进行了高度泛化，可以表示**任意数目、任意类型**的参数，其语法为：在 class 或 typename 后面带上省略号”。例如：

```c++
Template<class ... T>
void func(T ... args)
{
	cout<<”num is”<<sizeof ...(args)<<endl;
}
func();     //args 不含任何参数
func(1);    //args 包含一个 int 类型的实参
func(1,2.0) //args 包含一个 int 一个 double 类型的实参
```

其中 T 叫做**模板参数包**，args 叫做**函数参数包**

省略号作用如下：

- 声明一个包含 0 到任意个模板参数的参数包

- 在模板定义的右边，可以将参数包展成一个个独立的参数


C++11 可以使用**递归函数**的方式展开参数包，获得**每个可变参数**的值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：

```c++
#include <iostream>
using namespace std;
// 最终递归函数
void print()
{
	cout << "empty" << endl;
}
// 展开函数
template void print(T head, Args... args)
{
	cout << head << ","; print(args...);
}
int main()
{
	print(1, 2, 3, 4); 
    return 0;
}
```

参数包 Args ...在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数 printf 终止递归过程。

















