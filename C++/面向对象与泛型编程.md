<!-- GFM-TOC -->

* [引用折叠](#引用折叠)
* [左值和右值](#左值和右值)
* [右值引用](#右值引用)
  * [1移动语意](#1移动语意)
  * [2完美转发](#2完美转发)

<!-- GFM-TOC -->



# 引用折叠

引用折叠：创建引用的引用时（如模板参数、类型别名）会造成引用折叠，折叠规则如下：

- T& & => T&
- T& && => T&
- T&& & => T&
- T&& && => T&&





# 左值和右值

## 概念

1. 左值(lvalue)：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的**持久对象**。
2. 右值(rvalue)：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的**临时对象**。右值包括**纯右值**和**将亡值**，纯右值主要包括**常量**，将亡值主要指**临时变量**，被const修饰的变量也是右值，只能读不能写。

## 区别

1. 左值可以**寻址**，而右值不可以。
2. 左值可以被**赋值**，右值不可以被赋值，可以用来给左值赋值。
3. 左值**可变**，右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。
4. 当对象被用作左值的时候，用的是对象的在内存中的**位置**；当一个对象被用作右值的时候，用的是对象的值。



# 右值引用

普通引用称为左值引用(lvalue reference)，右值引用(rvalue reference)是 C++11 中引入的新特性 , 使用的符号是`&&`。右值引用实质上就是将匿名变量取了个别名，**右值引用本质是左值**。

左值引用只能绑定左值，右值引用只能绑定右值，否则编译就会失败。常量左值引用可以算是一个“万能”的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。

```c++
int& a = 1; //编译错误! 1是右值，不能够使用左值引用
int&& a = 1; //正确，右值引用实质上就是将不具名(匿名)变量取了个别名
int b = 1;
int && c = b; //编译错误！ 不能将一个左值复制给一个右值引用
int && c = std::move(b);  //正确，使用move移动语意，转换左值为右值引用

class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
A && a = getTemp();   //getTemp()的返回值是右值（临时变量）
```

`getTemp()`返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量）。而通过右值引用，其生命期将与右值引用类型变量`a`的生命期一样，只要`a`还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字。

右值引用实现了**移动语义**和**完美转发**。使用：

`std::move(a) `将左值 a 转化为右值；

`std::forward(a)` 将右值引用 a 转化为右值。

## 1移动语意

移动语意(`std::move`)，可以将左值转化为右值引用。消除**两个对象交互**时不必要的对象拷贝，节省运算存储资源，提高效率。

```c++
class myVector 
{
    int size;
    double* array;
public:
    // 复制构造函数
    myVector(const myVector& rhs) 
    {  
        size = rhs.size; 
        array = new double[size];
        for (int i=0; i<size; i++) 
            array[i] = rhs.array[i]; 
	}

    myVector(int n) 
    {
        size = n;
        array = new double[n];
    }
};

void foo(myVector v) {...}
myVector createMyVector {... /*返回值是一个 MyVector*/}
int main() 
{
	myVector reusable = createMyVector();
	foo(createMyVector());
	// createMyVector 会返回一个临时的右值，传参过程中会调用拷贝构造函数，多余地被复制一次
}
```

解决方法, 添加一个移动构造函数，那么，`foo(createMyVector())`就不会调用拷贝构造函数，而会调用移动构造函数。

```c++
// 移动构造函数
myVector(myVector&& rhs) 
{  
    size = rhs.size; 
    array = rhs.array;
    rhs.size = 0;
    rhs.array = nullptr;
}
```

## 2完美转发

Perfect Forwarding，即完美转发，也被译为精确传递，能够更简洁明确地定义**泛型函数**。

适用于这样的场景：需要将一组参数原封不动的传递给另一个函数。不仅仅是参数的值不变，还有**左值／右值**和 **const/non-const**。 完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变。在泛型函数中，这样的需求非常普遍。`std::forward`是在代码实现过程中，保持实参的原有的引用类型（左引用或者右引用类型）。

`std::forword` 等于是**把右值引用(右值引用本身是个左值)转成了右值**，左值保持不变。实现如下：

```c++
template<class T>
T&& forward(typename remove_reference<T>::type& arg) 
{
  return static_cast<T&&>(arg);
}
```

参数转发：

```c++
class myVector {...} 
myVector createMyVector {... /*返回值是一个 MyVector*/}

void foo(myVector& v) {}
void foo(myVector&& v) {}

template<typename T>  // 参数转发
void relay(T arg) 
{
	foo(arg);
}
int main() 
{
	myVector reusable= reateMyVector();
	relay(reusable); // 拷贝构造函数
	relay(createMyVector()); // 移动构造函数
}
```

此时定义了的两个 `foo`只有 `foo(myVector& v)` 会被调用 ，因为右值引用`myVector&& v`是个左值。

所以，我们需要改写上文的 relay 函数，借助 `std::forward`：

```c++
template<typename T>
void relay(T&& arg) 
{
    foo(std::forward<T>(arg));
}
```

于是就有：`relay(reusable)` 调用 `foo(myVector&)`；`relay(createMyVector()) `调用 `foo(myVector&&)`。



