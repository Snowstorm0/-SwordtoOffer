<!-- GFM-TOC -->

* [STL](#STL)
* [map和set](#map和set)
* [allocator](#allocator)
* [STL迭代器删除元素](#STL迭代器删除元素)
* [vector和list](#vector和list)
* [STL迭代器](#STL迭代器)
* [epoll原理](#epoll原理)
* [resize和reserve](#resize和reserve)
* [编程题](#编程题)
    * [比元素大的第一个数](#比元素大的第一个数)


<!-- GFM-TOC -->

# STL

**STL**，即 Standard Template Library，标准模板库，是C++的重要组成部分。C++ STL提供了通用的模板类和函数，可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。STL 几乎所有的代码都采用了模板类或者模板函数。

## 广义划分

STL 从广义上分为: **容器**(container)、**算法**(algorithm)、**迭代器**(iterator)。容器和算法之间通过迭代器进行无缝连接。

| **组成部分**     | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| iterator(迭代器) | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |
| container(容器)  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |
| Algorithm(算法)  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |

## 具体划分

STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器

1. 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。
2. 算法：各种常用的算法，如sort、find、copy、for_each等。
3. 迭代器：扮演了容器与算法之间的胶合剂。
4. 仿函数：行为类似函数，可作为算法的某种策略。
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
6. 空间配置器：负责空间的配置与管理。

他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数。

### 仿函数

重载函数调用操作符的类，其对象常称为**函数对象**。函数对象使用重载的`()`时，行为类似函数调用，也叫**仿函数**。函数对象(仿函数)是一个**类**，不是一个函数。



# map和set

**map** 是c++ key value存储容器，底层使用红黑树（自平衡二叉查找树）， 结构具有自动排序功能， 1个key对应1个value， 查找**O(logN)**

**unordered_map** 是c++ 另外一种 key value 存储容器，底层使用哈希表，不具备排序功能，1个key对应1个value 查找**O(1)**

**multimap** 是c++ key value 存储容器，底层使用红黑树， 结构具有自动排序功能，允许一个key对应多个value  查找**O(logN)**

**set** 是c++ key 存储容器，底层使用红黑树， 结构具有自动排序功能， 不予许key重复 查找**O(logN)**

**unordered_set** 是c++ 另外一种 key存储容器，底层使用哈希表，不具备排序功能，不予许key重复 查找**O(1)**

**multiset** 是c++ 另外一种 key存储容器，底层使用哈希表，具备排序功能，予许key重复 查找**O(logN)**



map赋值：

```c++
m["first"] = "hello";
m["second"] = "world"; 
```

map取出键值：

```c++
m.begin()->first;  //得到key
m.begin()->second; //得到value
```



##  map和set区别

（1）map 中的元素是 **key-value对**：关键字起到索引的作用，值则表示与索引相关联的数据；set 与之相对就是关键字的简单集合，只有key没有value，value就是key。

（2）map **允许修改 value**，但不允许修改key；set 的迭代器是 const 的，不允许修改元素的值。其原因是因为 map 和 set 是根据关键字排序来保证其有序性的，如果允许修改 key 的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了 map 和 set 的结构，导致 iterator 失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以 STL 中将 set 的迭代器设置成 const，不允许修改迭代器的值；而 map 的迭代器则不允许修改 key 值，允许修改 value 值。

（3）map 支持**下标操作**，set 不支持下标操作。map 可以用 key 做下标，map 的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和 mapped_type类型默认值的元素至 map 中，因此下标运算符[ ]在 map 应用中需要慎用。const_map 不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type 类型没有默认值也不应该使用。如果 find 能解决需要，尽可能用 find。





# allocator

STL 分配器，为了将**内存分配**和**对象构造**分开，以免造成不必要的浪费。

new 运算分两个阶段：

1. 调用`::operator new` 配置内存;
2. 调用对象**构造函数**构造对象内容。

delete 运算分两个阶段：

1. 调用对象**析构函数**；
2. 调用`::operator delete` 释放内存

为了精密分工，STL allocator 将两个阶段操作区分开来：

内存配置有 `alloc::allocate()`负责，内存释放由 `alloc::deallocate()`负责；

对象构造由`::construct()`负责，对象析构由`::destroy()`负责。

同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL 采用了两级配置器，当分配的空间大于128B 时，会使用第一级空间配置器；当分配的空间小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用 malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。



# STL迭代器删除元素

主要是迭代器失效的问题。

1.对于顺序式容器 vector、deque 、string来说，使用了连续分配的内存的（分配一个数组作为内存），使用erase(iterator)后，后边的**每个元素的迭代器都会失效**，但是后边每个元素都会往前移动一个位置，以保证数据的紧凑，但是 erase 会返回**下一个有效的**迭代器；

2.对于节点式容器 map、set 来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用 erase 之前，对**迭代器进行后移**的操作记录下一个元素的迭代器即可。

3.对于节点式容器 list来说，它使用了不连续分配的内存，并且它的 erase 方法也会返回下一个有效的 iterator，因此上面两种正确的方法都可以使用。



# vector和list

## 1vector

连续存储的容器，**动态数组**，在堆上分配空间。

底层实现：数组

**两倍扩容**：vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。

性能：

- 访问： O(1)
- 插入：在最后插入（空间够）：很快
- 在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
- 在中间插入（空间够）：内存拷贝
- 在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
- 删除：在最后删除：很快
- 在中间删除：内存拷贝

适用场景：经常随机访问，且不经常对非尾节点进行插入删除。

## 2list

**动态链表**，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。
底层：**双向链表**

性能：

1. 访问：随机访问性能很差，只能快速访问头尾节点。
2. 插入：很快，一般是常数开销
3. 删除：很快，一般是常数开销
4. 适用场景：经常插入删除大量数据

## 3区别

1. vector 底层实现是数组；list 是双向链表。
2. vector 支持随机访问，list 不支持。
3. vector 是顺序内存，list 不是。
4. vector 在中间节点进行插入删除会导致内存拷贝，list 不会。
5. vector 一次性分配好内存，不够时才进行 2 倍扩容；list 每次插入新节点都会进行内存申请。
6. vector 随机访问性能好，插入删除性能差；list 随机访问性能差，插入删除性能好。

## 4应用

vector 拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用 vector。list 拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用 list。



# STL迭代器

Iterator（迭代器）模式又称 **cursor（游标）模式**，用于提供一种方法顺序访问一个**聚合对象中各个元素**， 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator 模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由 iterator 提供的方法）访问聚合对象中的各个元素。由于 Iterator 模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如 STL 的 list、vector、stack 等容器类及 ostream_iterator 等扩展 iterator。

## 和指针的区别

迭代器不是指针，是**类模板**，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，`->`、`*`、`++`、`--`等。迭代器封装了指针，是一个“可遍历 STL容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的`++`，`--`等操作。迭代器**返回的是对象引用**而不是对象的值，所以 cout 只能输出迭代器使用`*`取值后的值而不能直接输出其自身。



# epoll原理

调用顺序：

```c++
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);
```

首先创建一个 epoll 对象，然后使用 `epoll_ctl` 对这个对象进行操作，把需要监控的**描述**添加进去。`epoll_ctl` 用于**向内核注册新的描述符**或者是**改变某个文件描述符的状态**。已注册的描述符在内核中会以**epoll_event结构体**的形式组成一颗红黑树。接着阻塞在`epoll_wait`，进入大循环，当某个 fd 上有事件发生时，内核将会把其对应的 I/O 准备好的描述符体放入到一个链表中，返回有事件发生的链表，进程调用 `epoll_wait`便可以得到**事件完成的描述符**。

从上面的描述可以看出，epoll **只需要将描述符从进程缓冲区向内核缓冲区拷贝一次**，并且进程不需要通过轮询来获得事件完成的描述符。

epoll 仅适用于 Linux OS。

epoll 比 select 和 poll 更加灵活而且**没有描述符数量限制**。

epoll 对多线程编程更有友好，一个线程调用了 `epoll_wait` 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。



# resize和reserve

resize()：改变当前容器内含有**元素的数量**(`size()`)。例如： `vector<int>v; v.resize(len);`v的 size 变为 len，如果原来 v 的 size 小于 len，那么容器新增（len-size）个元素，元素的值为默认为 0。当 `v.push_back(3);`之后，则是 3 是放在了 v 的末尾，即下标为 len，此时容器是 size为 len+1；

reserve()：改变当前容器的**最大容量**（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果`reserve(len)`的值大于当前的 capacity()，那么会**重新分配**一块能存 len 个对象的空间，然后把之前`v.size()`个对象通过 copy construtor 复制过来，销毁之前的内存；测试代码如下：

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    vector<int> a;
    a.reserve(100);
    a.resize(50);
    cout<<a.size()<<" "<<a.capacity()<<endl;
    //50 100
    a.resize(150);
    cout<<a.size()<<" "<<a.capacity()<<endl;
    //150 200
    a.reserve(50);
    cout<<a.size()<<" "<<a.capacity()<<endl;
    //150 200
    a.resize(50);
    cout<<a.size()<<" "<<a.capacity()<<endl;
//50 200
}
```





# 编程题

## 比元素大的第一个数

n 个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为 O(N)。

```c++
vector<int> findMax(vector<int>num)
{
    if(num.size()==0)
        return num;
    vector<int>res(num.size());
    int i=0;
    stack<int>s;
    while(i<num.size())
    {
        //如果栈空或者当前num元素不大于栈顶，将当前元素压栈，索引后移
        if(s.empty()||num[s.top()]>=num[i])
        {
        	s.push(i++);
        }
         //有待处理元素，且num当前元素大于栈顶索引元素，符合条件，更新结果数组中该索引的值，栈顶出栈
        else
        {
            res[s.top()]=num[i];
            s.pop();
        }
    }
    while(!s.empty())
    {
        res[s.top()]=INT_MAX;
        s.pop();
    }
    for(int i=0; i<res.size(); i++)
    	cout<<res[i]<<endl;
    return res;
}
```






























