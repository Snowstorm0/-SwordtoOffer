<!-- GFM-TOC -->

* [类的三大特性](#类的三大特性)
  * [封装](#封装)
  * [继承](#继承)
  * [多态](#多态)
* [类成员的权限](#类成员的权限)
  * [访问权限](#访问权限)
  * [继承权限](#继承权限)
* [struct和class](#struct和class)
* [类内定义引用数据成员](#类内定义引用数据成员)

<!-- GFM-TOC -->





 

# 类的三大特性

面向对象编程的主要思想是把构成问题的各个事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述一个事物在解决问题中经过的步骤和行为。类是创建对象的一个模板

## 封装

定义：封装就是将抽象得到的**数据和程序**相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，**形成类**，其中**数据和函数都是类的成员**，目的在于将对象的使用者和设计者分开，以提高软件的可维护性和可修改性

（1）构造函数

数据成员是不能在类中初始化的，而构造函数，正是为此而生，主要用来处理数据成员的初始化。它不需要用户调用，而是在建立对象时自动执行的。

## 继承

定义：继承就是**新类从已有类那里得到已有的特性**。 **类的派生**指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承父类后，可以**创建子类对象来调用父类函数，变量**等。

（1）继承方式

（1.1）单一继承：继承一个父类，这种继承称为单一继承，一般情况尽量使用单一继承，使用多重继承容易造成混乱易出问题

（1.2）多重继承：**继承多个父类**，类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加类名限定符如c.a::i = 1；

（1.3）菱形继承：多重继承掺杂隔代继承1-n-1模式，此时需要用到**虚继承**，例如 B，C虚拟继承于A，D再多重继承B，C，否则会出错

继承权限：继承方式规定了如何访问继承的基类的成员。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限。继承可以扩展已存在的代码，目的也是为了代码重用。继承也分为接口继承和实现继承：

（2）三种访问权限：

（2.1）public:可以被任意实体访问

（2.22）protected:只允许本类和子类的成员函数访问

（.3）private:只允许本类的成员函数访问

访问权限图如下：

​                               

（3）存储：父类所有的非静态成员属性都会被继承下去（占用空间），只是private属性被隐藏了。

（4）访问：访问子类同名成员，直接访问即可；**访问父类同名成员，需要加作用域**。对于成员函数，即使子类和父类发生重载，访问父类也必须加作用域。同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（**通过对象**和**通过类名**）。

```c++
void test01()
{
  //通过对象访问
  cout << "通过对象访问： " << endl;
  Son s;
  cout << "Son 下 m_A = " << s.m_A << endl;
  cout << "Base 下 m_A = " << s.Base::m_A << endl;
    
  //通过类名访问
  cout << "通过类名访问： " << endl;
  cout << "Son 下 m_A = " << Son::m_A << endl;
  cout << "Base 下 m_A = " << Son::Base::m_A << endl;
}
```



## 多态

多态简单的说就是“**一个函数，多种实现**”，是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。

C++的多态是通过虚函数来实现的，在基类中定义一个函数为虚函数，该函数就可以在运行时，根据传入的对象调用不同的实现方法。而如果该函数不设为虚函数，则在调用的过程中调用的函数就是固定的。

### 1、静态多态

是在**编译期就把函数链接起来**，此时即可确定调用哪个函数或模板，静态多态是由模板和重载实现的，在宏多态中，是通过定义变量，编译时直接把变量替换，实现宏多态

优点：带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的武器； 在编译期完成多态，**提高运行期效率**；具有很强的适配性和松耦合性，（耦合性指的是两个功能模块之间的依赖关系）

缺点： 程序可读性降低，代码调试带来困难；**无法实现模板的分离编译**，当工程很大时，编译时间不可小觑 ；无法处理异质对象集合

### 2、动态多态

是指在**程序运行时才能确定函数和实现的链接**，此时才能确定调用哪个函数，父类指针或者引用能够指向子类对象，调用子类的函数，所以在编译时是无法确定调用哪个函数。

### 3、多态的实现：

使用时在**父类中写一个虚函数**，**在子类中重写，用这个父类指针调用这个虚函数，它实际上会调用子类重写的虚函数。**

#### 虚函数

用virtual关键字修饰的函数。本质是由**虚指针**和**虚表控制**，虚指针指向虚表中的某个函数入口地址，就实现了多态。

说明：本来基类指针是用来指向基类对象的，如果用它指向派生类对象，则需要进行指针类型转换，即将派生类对象的指针先转换为基类的指针，所以基类指针指向的是派生类对象中的基类部分。如果基类中的 display函数不是虚函数，是无法通过基类指针去调用派生类对象中的成员函数的。虚函数突破了这一限制，**在派生类的基类部分中，派生类的虚函数取代了基类原来的虚函数**，因此在使基类指针指向派生类对象后，调用虚函数时就调用了派生类的虚函数。要注意的是，只有用 virtual声明了虚函数后才具有以上作用，如果不声明为虚函数，企图通过基类指针调用派生类的非虚函数则是不行的。

#### 纯虚函数

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容。因此可以将虚函数改为纯虚函数。当类中有了纯虚函数，这个类也称为**抽象类**。

抽象类特点：

1. 无法实例化对象，只能构建指针指向对象；
2. 子类必须重写抽象类中的纯虚函数，否则也属于抽象类。

```c++
//类中只要有一个纯虚函数就称为抽象类
class Base
{
public:
  //纯虚函数
  virtual void func() = 0;
};
```

#### 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。解决方式：将**父类中**的析构函数改为**虚析构**或者纯虚析构。虚析构和纯虚析构共性：可以解决**父类指针释放子类对象**；都需要有具体的**函数实现**。

虚析构和纯虚析构区别：如果是纯虚析构，该类属于抽象类，无法实例化对象。

```c++
class Base
{
public:
  //纯虚函数
  virtual void func() = 0;
};
void test01()
{
  //通过父类指针指向子类对象，会导致子类对象可能清理不干净，造成内存泄漏
  Animal *animal = new Cat("Tom");
  animal->Speak();
  //怎么解决？给基类增加一个虚析构函数 virtual ~Animal() = 0;
  //虚析构函数就是用来解决通过父类指针释放子类对象
  delete animal;
}
```

 

 

 



# 类成员的权限

## 访问权限

C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在**类的内部没有访问权限的限制**，无论成员被声明为 public、protected 还是 private，都可以互相访问。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 **public** 属性的成员，不能访问 private、protected 属性的成员

## 继承权限

<img src="../0other/0/pics/class继承.jpg" width="700px" />



# struct和class

在 C++中，可以用 struct 和 class 定义类，都可以继承。

区别在于：

1. struct 的默认继承权限和默认访问权限是 public，而 class 的默认继承权限和默认访问权限是 private。
2. class 还可以定义**模板类形参**，比如 `template <class T, int i>`。



# 类内定义引用数据成员

C++可以类内定义引用数据成员，必须通过**成员函数初始化列表**初始化。



