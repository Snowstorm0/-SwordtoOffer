<!-- GFM-TOC -->

* [static关键字](#static关键字)
  * [1.全局静态变量](#1.全局静态变量)
  * [2.局部静态变量](#2.局部静态变量)
  * [3.静态函数](#3.静态函数)
  * [4.类的静态成员](#4.类的静态成员)
  * [5.类的静态函数](#5.类的静态函数)
* [C++和C的区别](#C++和C的区别)
* [C++中四种cast转换](#C++中四种cast转换)
  * [1.const_cast](#1.const_cast)
  * [2.static_cast](#2.static_cast)
  * [3.dynamic_cast](#3.dynamic_cast)
  * [4.reinterpret_cast](#4.reinterpret_cast)
  * [5.为何不用C的强制转换](#5.为何不用C的强制转换)
* [C/C++中指针和引用的区别](#C/C++中指针和引用的区别)
* [C++智能指针](#C++智能指针)
  * [1.auto_ptr](#1.auto_ptr)
  * [2.unique_ptr](#2.unique_ptr)
  * [3.shared_ptr](#3.shared_ptr)
  * [4.weak_ptr](#4.weak_ptr)
  * [5.内存泄露](#5.内存泄露)

* [数组和指针](#数组和指针)
* [野指针](#野指针)
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
  * 
  * [2.static_cast](#2.static_cast)
  * [3.dynamic_cast](#3.dynamic_cast)
  * [4.reinterpret_cast](#4.reinterpret_cast)
  * [5.为何不用 C 的强制转换](#5.为何不用 C 的强制转换)
* [编程题](#编程题)
  * [1.点是在三角形内](#1.点是在三角形内)
  * [2.判断一个数是二的倍数](#2.判断一个数是二的倍数)
  * [3.一个数中有几个1](#3.一个数中有几个1)
  * [4.reinterpret_cast](#4.reinterpret_cast)
  * [5.为何不用 C 的强制转换](#5.为何不用 C 的强制转换)
  * 
* <!-- GFM-TOC -->

# static关键字

加了 static 关键字的全局变量只能在**本文件**中使用。

static 定义的静态局部变量分配在**数据段**上，普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。

## 1.全局静态变量

在全局变量前加上关键字 static，全局变量就定义成一个**全局静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被**自动初始化为 0**（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明**仅在本文件可见**，他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

## 2.局部静态变量

在局部变量之前加上关键字 static，局部变量就成为一个**局部静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为 0（自动对象的值是任意的，除非他被显式初始化）；
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是**仍然驻留在内存当中**，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

## 3.静态函数

在函数返回类型前加 static，函数就定义为**静态函数**。函数的定义和声明在默认情况下都是 extern 的，但静态函数**仅在本文件可见**，不能被其他文件所用。
函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同名函数引起冲突；
warning：在**头文件中声明非static 的全局函数**，在 **cpp 内声明static 的全局函数**，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；

## 4.类的静态成员

 对一个类中成员变量和成员函数来说，加了 static 关键字，则此变量/函数就**没有 this指针**了，必须通过**类名访问**。

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员**，而不是某个对象的成员。对多个对象来说，静态数据成员**只存储一处**，供所有对象共用。

## 5.类的静态函数

静态成员函数和静态数据成员一样，它们都属于**类的静态成员**，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在**静态成员函数的实现中不能直接引用类中说明的非静态成员**，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);



# C++和C的区别

## 设计思想上

C++是**面向对象**的语言，而 C 是面向过程的结构化编程语言

## 语法上

C++具有**重载**、**继承**、**多态**三种特性；
C++相比 C，增加多许多类型安全的功能，比如强制类型转换；
C++支持**范式编程**，比如模板类、函数模板等。



# C++中四种cast转换

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

## 1.const_cast

用于将 **const** 变量转为**非 const**。它也是四个强制类型转换运算符中**唯一**能够去除 const 属性的运算符。对于未定义 const 版本的成员函数，我们通常需要使用 const_cast 来去除 const引用对象的 const，完成函数调用。另外一种使用方式，结合 static_cast，可以在非 const 版本的成员函数内添加 const，调用完 const 版本的成员函数后，再使用 const_cast 去除 const限定。

## 2.static_cast

```c++
static_cast< new_type >(expression)
// new_type 为目标数据类型，expression 为原始数据类型变量或者表达式。
```

基本数据类型之间的转换，如int、float、char之间的互相转换；用于各种**隐式转换**，比如非 const 转 const，void*转指针等，但**没有运行时类型检查来保证转换的安全性**。

**隐式类型转换**：首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成**临时对象**。

static_cast主要有如下几种用法：

1. 用于类层次结构中**基类**和**派生类**之间指针或引用的转换。
   进行**向上**转换是**安全**的； 

   进行**向下**转换时，由于没有动态类型检查，所以是**不安全**的。因为 基类不包含派生类的成员变量，无法对派生类的成员变量赋值。

2. 用于基本数据类型之间的转换，如int、float、char之间的互相转换

3. 把空指针转换成**目标类型的空指针**。 

4. 把任何类型的表达式转**换成void类型**。 

注意：static_cast不能**去掉**expression的const、volatile、或者__unaligned属性。

```c++
char a = 'a'; int b = static_cast<char>(a);  //将char型数据转换成int型数据

const int g = 20;
int *h = static_cast<int*>(&g);   //编译错误，static_cast不能去掉g的const属性
```

```c++
class Base
{};
class Derived : public Base
{}

Base* pB = new Base();
if(Derived* pD = static_cast<Derived*>(pB))
{}  //下行转换是不安全的(坚决抵制这种方法)

Derived* pD = new Derived();
if(Base* pB = static_cast<Base*>(pD))
{}   //上行转换是安全的
```

## 3.dynamic_cast

```c++
dynamic_cast< new_type >(expression)
// new_type 为目标数据类型，expression 为原始数据类型变量或者表达式。
dynamic_cast< type* >(e)   //type必须是一个类类型且必须是一个有效的指针 
dynamic_cast< type& >(e)   //type必须是一个类类型且必须是一个左值 
dynamic_cast< type&& >(e)  //type必须是一个类类型且必须是一个右值
```

用于**动态类型转换**。只能用于**含有虚函数的类**，用于类层次间的**向上**和**向下**转化、类之间的**交叉转换**（cross cast）。只能转**指针**或**引用**。

在类层次间**向上**转换时，dynamic_cast和static_cast的效果是一样的；在进行**向下**转换时，dynamic_cast具有**类型检查**的功能，它通过判断在执行到该语句的时候，变量类型和要转换的**类型是否相同**来判断是否能够进行向下转换，如果是非法的对于转换目标是**指针**类型返回 NULL，对于引用抛std::bad_cast异常比static_cast更安全。

## 4.reinterpret_cast

几乎什么都可以转，比如将 int 转指针，执行的是**逐个比特复制**的操作。容易出问题，尽量少用。

## 5.为何不用C的强制转换

C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。



# C/C++中指针和引用的区别

## 指针

指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到**以它为地址**的内存单元。

## 引用

引用就是某一变量的一个**别名**，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*

## 区别

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而对引用的修改都会改变引用所指向的对象；
5. 可以有 const 指针，但是没有 const 引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
7. 指针可以有多级指针（**p），而引用至于一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。



# C++智能指针

C++里面的四个智能指针: **auto_ptr**, **shared_ptr**, **weak_ptr**, **unique_ptr** 其中后三个是c++11 支持，并且第一个已经被 11 弃用。

为什么要使用智能指针：
智能指针的作用是**管理一个指针**，因为存在以下这种情况：申请的空间在函数结束时**忘记释放**，造成**内存泄漏**。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个**类**，当超出了类的作用域是，类会**自动调用析构函数**，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

对 shared_ptr 进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过 make_shared 函数或者通过构造函数传入普通指针。并可以通过 get 函数获得普通指针。

## 1.auto_ptr

c++98 的方案，cpp11 已经抛弃。

```c++
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错.
```

此时不会报错，**p2 剥夺了 p1 的所有权**，但是当程序运行时访问 p1 将会报错。所以 auto_ptr存在潜在的内存崩溃问题。

## 2.unique_ptr

替换 auto_ptr。unique_ptr 实现**独占式拥有**或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如：以 new 创建对象后因为发生异常而忘记调用 delete)特别有用。还是上面那个例子：

```c++
unique_ptr<string> p3 (new string ("auto")); //#4
unique_ptr<string> p4； //#5
p4 = p3;  //此时会报错！！
```

编译器认为 p4=p3 非法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr更安全。另外unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

```c++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1; // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You")); // #2 allowed
```

其中#1 留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2 不会留下悬挂的 unique_ptr，因为它调用unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr 。
注：如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数 **std::move()**，让你能够将一个 unique_ptr 赋给另一个。例如：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

## 3.shared_ptr

shared_ptr 实现**共享式拥有**概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使用**计数机制**来表明资源被几个指针共享。可以通过成员函数 use_count()来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用 release()时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
成员函数：

- **use_count** 返回引用计数的个数

- **unique** 返回是否是独占所有权( use_count 为 1)

- **swap** 交换两个 shared_ptr 对象(即交换所拥有的对象)

- **reset** 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

- **get** 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的。如：

  ```c++
  shared_ptr<int> sp(new int(1)); // sp 与 sp.get()是等价的
  ```

## 4.weak_ptr

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。weak_ptr 设计的目的是为**协助shared_ptr** 而引入的一种智能指针，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。

weak_ptr 是用来**解决 shared_ptr 相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。

```c++
class B;
class A
{
	public:
	shared_ptr<B> pb_;
	~A()
	{
		cout<<"A delete\n";
	}
};
class B
{
	public:
	shared_ptr<A> pa_;
	~B()
	{
		cout<<"B delete\n";
	}
};
void fun()
{
	shared_ptr<B> pb(new B());
	shared_ptr<A> pa(new A());
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout<<pb.use_count()<<endl;
	cout<<pa.use_count()<<endl;
}
int main()
{
	fun();
	return 0;
}  
```

可以看到 fun 函数中 pa，pb 之间互相引用，两个资源的引用计数为 2，当要跳出函数时，智能指针 pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为 1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为 weak_ptr 就可以了，我们把类 A 里面的` shared_ptr pb`改为` weak_ptr pb`运行结果如下，这样的话，资源 B 的引用开始就只有 1，当 pb 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为 0，A 得到释放。

注意的是我们不能通过 weak_ptr 直接访问对象的方法，比如 B 对象中有一个方法 print()，我们不能这样访问，`pa->pb->print();` 英文 pb_是一个 weak_ptr，应该先把它转化为shared_ptr，如：

```c++
shared_ptr p = pa->pb_.lock(); 
p->print();
```

## 5.内存泄露

当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成**循环引用**，使引用计数失效，从而导致内存泄漏。

```cpp
#include <iostream>  
#include <memory>  
using namespace std;  
  
class B;  
class A  
{  
public:  // 为了省去一些步骤这里 数据成员也声明为public  
    shared_ptr<B> pb;  
    ~A()  
    {  
        cout << "kill A\n";  
    }  
};  
class B  
{  
public:  
    shared_ptr<A> pa;  
    ~B()  
    {  
        cout <<"kill B\n";  
    }  
};  
int main(int argc, char** argv)  
{  
    shared_ptr<A> sa(new A());  
    shared_ptr<B> sb(new B());  
    if(sa && sb)  
    {  
        sa->pb=sb;  
        sb->pa=sa;  
    }  
    cout<<"sa use count:"<<sa.use_count()<<endl;  
    return 0;  
}
```

注意此时sa,sb都没有释放，产生了内存泄露问题。即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。

### 解决办法

使用弱引用的智能指针**weak_ptr**打破这种循环引用。为了解决循环引用导致的内存泄漏，引入了weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

## 6.shared_ptr的实现

```c++
template <typename T>
class SmartPtr
{
private:
    T *ptr; //底层真实的指针
    int *use_count;//保存当前对象被多少指针引用计数
public:
    SmartPtr(T *p); //SmartPtr<int>p(new int(2));
    SmartPtr(const SmartPtr<T>&orig);//SmartPtr<int>q(p);
    SmartPtr<T>&operator=(const SmartPtr<T> &rhs);//q=p
    ~SmartPtr();
    T operator*(); //为了能把智能指针当成普通指针操作定义解引用操作
    T*operator->(); //定义取成员操作
    T* operator+(int i);//定义指针加一个常数
    int operator-(SmartPtr<T>&t1, SmartPtr<T>&t2);//定义两个指针相减
    void getcount()
    {
        return *use_count
    }
};

template <typename T>
int SmartPtr<T>::operator-(SmartPtr<T> &t1, SmartPtr<T> &t2)
{
    return t1.ptr - t2.ptr;
}
template <typename T>
SmartPtr<T>::SmartPtr(T *p)
{
    ptr = p;
    try
    {
        use_count = new int(1);
    }
    catch (...)
    {
        delete ptr; //申请失败释放真实指针和引用计数的内存
        ptr = nullptr;
        delete use_count;
        use_count = nullptr;
    }
}
template <typename T>
SmartPtr<T>::SmartPtr(const SmartPtr<T> &orig) //复制构造函数
{
    use_count = orig.use_count;//引用计数保存在一块内存，所有的 SmarPtr 对象的引用计数
    都指向这里
        this->ptr = orig.ptr;
    ++(*use_count); //当前对象的引用计数加 1
}
template <typename T>
SmartPtr<T>& SmartPtr<T>::operator=(const SmartPtr<T> &rhs)
{
    //重载=运算符，例如 SmartPtr<int>p,q; p=q;这个语句中，首先给 q 指向的对象的引用计数加1，因为 p 重新指向了 q 所指的对象，所以 p 需要先给原来的对象的引用计数减 1，如果减一后为 0，先释放掉 p 原来指向的内存，然后讲 q 指向的对象的引用计数加 1 后赋值给 p
    ++*(rhs.use_count);
    if ((--*(use_count)) == 0)
    {
        delete ptr;
        ptr = nullptr;
        delete use_count;
        use_count = nullptr;
    }
    ptr = rhs.ptr;
    *use_count = *(rhs.use_count);
    return *this;
}
template <typename T>
SmartPtr<T>::~SmartPtr()
{
    getcount();
    if (--(*use_count) == 0) //SmartPtr 的对象会在其生命周期结束的时候调用其析构函数，在析构函数中检测当前对象的引用计数是不是只有正在结束生命周期的这个 SmartPtr 引用，如果是，就释放掉，如果不是，就还有其他的 SmartPtr 引用当前对象，就等待其他的 SmartPtr对象在其生命周期结束的时候调用析构函数释放掉
    {
        getcount();
        delete ptr;
        ptr = nullptr;
        delete use_count;
        use_count = nullptr;
    }
}
template <typename T>
T SmartPtr<T>::operator*()
{
    return *ptr;
}
template <typename T>
T* SmartPtr<T>::operator->()
{
    return ptr;
}
template <typename T>
T* SmartPtr<T>::operator+(int i)
{
    T *temp = ptr + i;
    return temp;
}
```







# 数组和指针

| 指针                                 | 数组                                 |
| ------------------------------------ | ------------------------------------ |
| 保存数据的地址                       | 保存数据                             |
| 指针的内容为为地址，从该地址访问数据 | 直接访问数据                         |
| 通常用于动态的数据结构               | 通常用于固定数目且数据类型相同的元素 |
| 通过 Malloc 分配内存，free 释放内存  | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名函数       | 自身即为数据名                       |




# 野指针

野指针就是指向一个**已删除的对象**或者**未申请访问受限内存区域**的指针



# 函数指针

## 1.定义

函数指针是**指向函数的指针**变量。
函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。
C 在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

## 2.用途：

调用函数和做函数的参数，比如回调函数。

## 3.示例：

```c++
char * fun(char * p) {…}   // 函数 fun
char * (*pf)(char * p);    // 函数指针 pf
pf = fun;                  // 函数指针 pf 指向函数 fun
pf(p);                     // 通过函数指针 pf 调用函数 fun
```

# fork函数

Fork：创建一个和当前进程映像一样的**进程**可以通过 fork( )系统调用：

```c++
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

成功调用 fork( )会**创建一个新的进程**，它几乎与调用 fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的 fork( )调用会返回 0。在父进程中 fork( )返回子进程的 pid。如果出现错误，fork( )返回一个负值。

最常见的 fork( )用法是创建一个新的进程，然后使用 **exec( )**载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

在早期的 Unix 系统中，创建进程比较原始。当调用 fork 时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的 Unix 系统采取了更多的优化，例如 Linux，采用了**写时复制**的方法，而不是对父进程空间进程整体复制。

# 析构函数

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如`~stud( )`，以区别于构造函数。它**不能带任何参数，也没有返回值**（包括 void 类型）。只能有一个析构函数，**不能重载**。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

## 类析构顺序

1. 派生类本身的析构函数
2. 对象成员析构函数
3. 基类析构函数

因为析构函数没有参数，所以包含成员对象的类的析构函数形式上并无特殊之处。但在撤销该类对象的时候，会首先调用自己的析构函数，再调用成员对象的析构函数，调用次序与初始化时的次序相反。



# 虚函数

C++使用函数继承的方法快速实现开发，而为了满足多态与泛型编程这一性质，C++允许用户使用虚函数 **(virtual function)** 来完成 **运行时决议** 这一操作，这与一般的 **编译时决定**有着本质的区别。

当一个类中包含被virtual 关键字修饰的成员函数时，该成员函数就成为了一个**虚函数**。第一个含有虚函数的类所实例化出来的对象都拥有同一个**虚函数表**，在对象中含有一个**虚函数指针 *_vptr**，该指针指向该类的虚函数表，虚函数表保存的是**类中虚函数的地址**（一个类可能有多个虚函数），实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，我们就说这两个类构成**多态**，此时会将其继承到的**虚函数表中的地址替换为重新写的函数地址**。从而基类与子类调用同名的虚函数时，所调用的就不是同一个函数，从而体现了多态和虚函数表的作用。使用了虚函数，会增加访问内存开销，降低效率。

##  1.多态和虚函数

多态的实现主要分为**静态多态**和**动态多态**，**静态多态主要是重载**，在**编译的时候就已经确定**；**动态多态是用虚函数**机制实现的，在**运行期间动态绑定**。例如：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中**重写**了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了 virtual 关键字的函数，在子类中重写时候不需要加 virtual也是虚函数。

## 2.析构函数和虚函数

析构函数必须是虚函数，因为将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用基类指针指向该子类对象`TestFather* p = new TestChild()`，**释放基类指针时可以释放掉子类的空间**，防止内存泄漏。否则直接给编译器一个基类的指针，delete的时候，编译器一看是基类的析构函数，直接调用基类析构函数，而没有析构子类。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的析构函数不是虚函数，而是只有当需要当作**父类**时，**设置虚函数**。

## 3.静态函数和虚函数

静态函数是用**static**修饰的函数，限定在本源码文件中使用，不能被本源码文件以外的代码文件调用。 普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。

**区别**：我们知道类的静态函数是没有this指针的，调用它时不需要创建对象，通过：类名 ：：函数名（参数）的形式直接调用。静态函数只有**唯一的**一份，因此它的**地址是固定不变的**， 所以编译的时候但凡遇到调用该静态函数的时候就知道调用的是哪一个函数，因此说**静态函数在编译的时候就已经确定运行时机。** 而虚函数则不然，看下面的代码：

```c++
class A
{
	public: 
	virtual void fun()
    {
        cout<<"i am A <<endl;
    }
}
class B: public A
{
	public:
	virtual  void  fun()
	{
        cout<<"I  am  B" <<endl;
    }
};
int main()
{
	A a ;
	B b;
	A*  pb = &b;
	pb->fun();
	return 0; 
}
```

类A与类B构成多态，创建了 A类指针pb指向 B类对象，当程序编译的时候只对语法等进行检测，该语句没有什么问题，但是编译器此时无法确定调用的是哪一个 fun() 函数，因为类A类B中都含有fun函数，因此只能是在程序运行的时候通过 pb指针查看对象的虚函数表（访问虚函数表就是所谓的访问内存）才能确定该函数的地址，即确定调用的是哪一个函数。这就解释了所说的“**虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。**”



# 重载和覆盖

## 重载

两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中。

## 重写

子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写，是一种同名覆盖。





# 在main函数前先运行的函数

**1.test0**：`__attribute((constructor))`是gcc扩展，标记这个函数应当在main函数之前执行。同样有一个`__attribute((destructor))`，标记函数应当在程序结束之前（main结束之后，或者调用了exit后）执行。

**2.test1**：全局static变量的初始化在程序初始阶段，先于main函数的执行。

```c++
#include <iostream> 
using namespace std;

__attribute((constructor)) void test0()
{
	printf("before main 0\n");
}

int test1()
{
    cout << "before main 1" << endl;
    return 54;
}

static int i = test1();
int main(int argc, char** argv) 
{
    cout << "main function." <<endl;
    return 0;
}
```

在leetcode里经常见到static，在main之前关闭cin与stdin的同步来“加快”速度的黑科技。

```c++
static int _ = []{
    cin.sync_with_stdio(false);
    return 0;
}();
```







# new/delete与malloc/free

1、new/delete是C++的操作符，而malloc/free是C语言的库函数。

2、new做两件事，一是分配内存，二是调用类的**构造函数**；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存，必须指明申请内存空间的大小，不会调用构造函数和析构函数。

3、new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用**成员函数访问**，不要直接访问它的地址空间；malloc分配的是一块内存区域，用**指针访问**，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。

4、new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持。



# select

select 在使用前，先将需要监控的描述符对应的 bit 位置 1，然后将其传给 select,当有任何一个事件发生时，select 将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大。

![Image text](../0other/0/pics/1093303-20170626104335696-1159292286.png)

<img src="../0other/0/pics/1093303-20170626104335696-1159292286.png" width="500px" />

<img src="../0other/0/pics/1093303-20170626104335696-1159292286.png" alt="Image text" style="zoom:50%;" />









# RTTI

RTTI(Run Time Type Identification)即通过**运行时类型识别**，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的**实际派生类型**。

C++是一种静态类型语言。其**数据类型是在编译期就确定**的，不能在运行时更改。然而**多态性的对象无法在程序编译阶段确定对象的类型**，其基类的指针就可以指向任何派生类的对象，导致C++中的指针或引用本身的类型，可能与它实际代表(指向或引用)的类型并不一致，例如基类指针指向该子类对象`TestFather* p = new TestChild()`。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息。

## typeid和dynamic_cast

RTTI提供了两个非常有用的操作符：typeid和dynamic_cast。

- typeid操作符：返回指针和引用所指的**实际类型**；
- dynamic_cast操作符：将基类类型的指针或引用安全地**转换**为其派生类类型的指针或引用。

## typeid

typeid函数的主要作用就是**返回当前变量类型**，比如使用`typeid(a).name()`就能知道变量a是什么类型的。typeid()函数的返回类型为typeinfo类型的引用，要使用typeid必须使用头文件`<typeinfo>`。

typeid函数是type_info类的一个引用对象，可以访问type_info类的成员。但因为不能创建type_info类的对象，而typeid又必须反回一个类型为type_info类型的对象的引用，所以怎样在typeid函数中创建一个type_info类的对象以便让函数反回type_info类对象的引用就成了问题。这可能是**把typid函数声明为了type_info类的友元函数**来实现的，默认构造函数并不能阻止该类的友元函数创建该类的对象。所以typeid函数如果是友元的话就可以访问type_info类的私有成员，从而可以创建type_info类的对象，从而可以创建返回类型为type_info类的引用。

## dynamic_cast

该转换符用于将一个**指向派生类的基类指针或引用转换为派生类的指针或引用**，注意dynamic_cast转换符只能用于**含有虚函数的类**，只能用于**指针**或者**引用**。其表达式为`dynamic_cast<类型>(表达式)`，其中的类型是指把表达式要转换成的目标类型，比如含有虚函数的基类TestFather和从基类派生出的派生类TestChild，则：

```c++
TestFather *p_father; 
TestChild *p_child, md; 
p_father = &md;
p_child = dynamic<TestChild*>(p_father); 
```

最后一条语句表示把指向派生类TestChild的基类指针p_father转换为派生类TestChild的指针，然后将这个指针赋给派生类TestChild的指针p_child。

**作用**：有些时候我们需要强制转换，比如如果指向派生类的基类指针想访问派生类中的除虚函数之外的成员时，就需要把该指针转换为指向派生类的指针，以达到**访问派生类中特有的成员**的目的，比如派生类中含有特有的成员函数g()，这时可以这样来访问该成员`dynamic_cast<D*>(p_father)->g();`因为dynamic_cast转换后的结果是一个指向派生类的指针，所以可以这样访问派生类中特有的成员。但是该语句不影响原来的指针的类型，即基类指针p_father仍然是指向基类的。

dynamic_cast转换操作符在执行类型转换时首先将检查能否成功转换，如果能成功转换则转换之，如果转换失败，如果是指针则反回一个**null**值，如果是引用则抛出一个**bad_cast**异常，所以在使用dynamic_cast转换之间应使用if语句对其转换成功与否进行测试，比如：

```c++
p_child = dynamic_cast<D*>(p_father);
if(p_child) {…}
else {…}
```





# extern“C”

C++调用 C 函数需要 extern C，因为 C 语言没有函数重载。



#  C 语言

## 1.函数调用

esp指针指向栈顶，而ebp指针指向栈底。

每一个函数调用都会分配**函数栈**，在栈内进行函数执行过程。调用前，先把**返回地址**压栈，然后把当前函数的 esp 指针压栈。

## 2.参数压栈顺序

从右到左。



# C++处理返回值

生成一个**临时变量**，把它的**引用**作为函数参数传入函数内。



#  拷贝赋值函数的形参

**C++中拷贝构造函数的形参不能进行值传递**。**拷贝赋值**如果为值传递，仅仅是多了一次拷贝，并不会无限递归。**拷贝构造**如果为值传递，才会引起无限递归。

## 构造函数

- 按参数分为： 有参构造和无参构造
- 按类型分为： 普通构造和拷贝构造

## 传递

- **值传递**： 只要是基本类型传递，都是值传递
- **引用传递**：针对于基本类型进行封装，对封装进行传递，是引用传递

如果C++中拷贝赋值函数的形参进行值传递，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数（`age = p.age;`）。如此循环，无法完成拷贝，栈也会满。

```c++
class Person {
public:
	Person(int a)   //有参构造函数
    {
		age = a;
	}
	Person(const Person& p) //拷贝构造函数，应该用引用传递
    {
		age = p.age;	//此处调用拷贝构造函数
	}
	~Person()  { }	
public:
	int age;
};

int main
{
	Person p2(10);  //调用有参构造函数
	Person p3 = Person(p2); //调用拷贝构造函数
}
```









# 内存管理

在 C++中，虚拟内存分为代码段、数据段、BSS 段、堆区、文件映射区以及栈区六部分。

1.**栈(stack)**：程序**自动分配**，使用栈空间存储函数的返回地址、参数、局部变量、返回值。

2.**堆(heap)**：

- **堆**：调用`malloc` 在堆区动态分配内存，调用 `free` 来手动释放。堆是**操作系统所维护**的一块特殊内存，它提供了动态分配的功能。
- **自由存储区**：由`new` 分配内存，用来 `delete` 手动释放。和堆类似，通过`new`来申请的内存区域可称为自由存储区。

3.**静态/全局区**：在 C++ 里面没有区分bss和data。

- **bss段**：存储**未初始化**的全局变量和静态变量（局部+全局），以及所有被**初始化为0**的全局变量和静态变量，Block Started by Symbol。
- **data段**：存储程序中**已初始化**的全局变量和静态变量。

4.**代码区**（code segment 或 text segment）：

- **代码段**：存放函数体的二进制代码，**text**段。
- **常量区**：只读数据，比如字符串常量，程序结束时由系统释放。**rodata段**，read only。

![img](https://img-blog.csdnimg.cn/20200805100740649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3piemNEWkY=,size_16,color_FFFFFF,t_70)



32bitCPU 可寻址 4G 线性空间，每个进程都有各自独立的 4G 逻辑地址，其中 0~3G 是**用户态**空间，3~4G 是**内核**空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

**映射区**：memory mapping segment，存储动态链接库等文件映射、申请大内存（malloc 时调用 mmap 函数）

## 栈空间

C++函数栈空间的最大值默认是 1M，不过可以调整。









# 内存泄漏

内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用 linux 环境下的**内存泄漏检查工具 Valgrind**，另一方面我们在写代码时可以添加内存申请和释放的**统计功能**，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

# 段错误

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：

1. 使用野指针
2. 试图修改字符串常量的内容





# 常量const

常量是固定值，在程序执行期间不会改变。常量可以是任何的基本数据类型，可分为int、float、char、string和bool。常量定义必须初始化。

## 存储区域

1. **局部常量**，存放在**栈区**；
2. **static/全局常量**，存放在**静态/全局存储区**；
3. **字面值常量**，其值一望而知，存放在**常量区**。

## const修饰成员函数

const 修饰的成员函数表明函数调用**不会对对象做出任何更改**，事实上，如果确认不会对对象做更改，就应该为函数加上 const 限定，这样无论 const 对象还是普通对象都可以调用该函数

若同时定义了两个函数，一个带 const，一个不带，这相当于函数的**重载**。



















# 代码解析

## 1.strcpy和strlen

strcpy 是字符串拷贝函数，原型：

```c++
char *strcpy(char* dest, const char *src);
```

从 src **逐字节拷贝**到 dest，直到遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是 strncpy 函数。

strlen 函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。

## 2.++i和i++

 ++i 实现：

```c++
int& int::operator++（）
{
    *this +=1；
    return *this；
}
```

i++ 实现：

```c++
const int int::operator（int）
{
    int oldValue = *this；
    ++（*this）；
    return oldValue；
}
```

## 3.代码的区别

（1）字符串 123 保存在**常量区**，const 本来是修饰 arr 指向的值，不能通过 arr 去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加 const 效果都一样：

```c++
const char * arr = "123";
```

（2）字符串 123 保存在常量区，这个 和arr 指针指向的是同一个位置，同样不能通过 brr 去修改"123"的值：

```c++
char * brr = "123";
```

（3）这里 123 本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区：

```c++
const char crr[] = "123";
```

（4）字符串 123 保存在**栈区**，可以通过 drr 去修改：

```c++
char drr[] = "123";
```






















# 编程题

## 1.点是在三角形内

给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内。

根据面积法，如果P在三角形ABC内，那么三角形ABP的面积+三角形BCP的面积+三角形ACP的面积应该等于三角形ABC的面积。
$$
S=(x1y2+x2y3+x3y1-x1y3-x2y1-x3y2)/2
$$
代码如下：

```c++
#include <iostream>
#include <math.h>
using namespace std;
#define ABS_FLOAT_0 0.0001
struct point_float
{
    float x;
    float y;
};

float GetTriangleSquar(const point_float pt0, const point_float pt1, const point_float pt2)  // 计算三角形面积
{
    point_float AB, BC;
    AB.x = pt1.x - pt0.x;
    AB.y = pt1.y - pt0.y;
    BC.x = pt2.x - pt1.x;
    BC.y = pt2.y - pt1.y;
    return fabs((AB.x * BC.y - AB.y * BC.x)) / 2.0f;
}

bool IsInTriangle(const point_float A, const point_float B, const point_float C, const point_float D)  // 判断给定一点是否在三角形内或边上
{
    float SABC, SADB, SBDC, SADC;
    SABC = GetTriangleSquar(A, B, C);
    SADB = GetTriangleSquar(A, D, B);
    SBDC = GetTriangleSquar(B, D, C);
    SADC = GetTriangleSquar(A, D, C);
    float SumSuqar = SADB + SBDC + SADC;
    if ((-ABS_FLOAT_0 < (SABC - SumSuqar)) && ((SABC - SumSuqar) < ABS_FLOAT_0))
    	return true;
    else
    	return false;
}
```



## 2.判断一个数是二的倍数

判断一个数是不是二的倍数，即判断该数二进制末位是不是 0：

```c++
a % 2 == 0  
a & 0x0001 == 0  // 两种办法都可
```



## 3.一个数中有几个1

可以直接逐位除十取余判断：

```
int fun(long x)
{
    int _count = 0;
    while(x)
    {
        if(x % 10 == 1)
            ++_count;
            x /= 10;
    }
    return _count;
}
int main()
{
    cout << fun(123321) << endl;
    return 0;
}
```













