<!-- GFM-TOC -->
* [ static 关键字](# static 关键字)
    * [1.全局静态变量](#1.全局静态变量)
    * [2. 共享](#2-共享)
    * [3. 虚拟](#3-虚拟)
    * [4. 异步](#4-异步)
* [基本功能](#基本功能)
    * [1. 进程管理](#1-进程管理)
    * [2. 内存管理](#2-内存管理)
    * [3. 文件管理](#3-文件管理)
    * [4. 设备管理](#4-设备管理)
* [系统调用](#系统调用)
* [大内核和微内核](#大内核和微内核)
    * [1. 大内核](#1-大内核)
    * [2. 微内核](#2-微内核)
* [中断分类](#中断分类)
    * [1. 外中断](#1-外中断)
    * [2. 异常](#2-异常)
    * [3. 陷入](#3-陷入)
<!-- GFM-TOC -->


#  static 关键字

## 1.全局静态变量

在全局变量前加上关键字 static，全局变量就定义成一个**全局静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被**自动初始化为 0**（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明**仅在本文件可见**，他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

## 2.局部静态变量

在局部变量之前加上关键字 static，局部变量就成为一个**局部静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为 0（自动对象的值是任意的，除非他被显式初始化）；
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是**仍然驻留在内存当中**，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

## 3.静态函数

在函数返回类型前加 static，函数就定义为**静态函数**。函数的定义和声明在默认情况下都是 extern 的，但静态函数**仅在本文件可见**，不能被其他文件所用。
函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同名函数引起冲突；
warning：在**头文件中声明非static 的全局函数**，在 **cpp 内声明static 的全局函数**，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；

## 4.类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员**，而不是某个对象的成员。对多个对象来说，静态数据成员**只存储一处**，供所有对象共用。

## 5.类的静态函数

静态成员函数和静态数据成员一样，它们都属于**类的静态成员**，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在**静态成员函数的实现中不能直接引用类中说明的非静态成员**，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

















































































































## 1. 并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

## 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

## 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 4. 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

# 基本功能

## 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

## 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

## 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

## 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

# 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div><br>

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :---: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |

# 大内核和微内核

## 1. 大内核

大内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

## 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>

# 中断分类

## 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

## 2. 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

## 3. 陷入

在用户程序中使用系统调用。






<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
