<!-- GFM-TOC -->

* [static关键字](#static关键字)
    * [1.全局静态变量](#1.全局静态变量)
    * [2.局部静态变量](#2.局部静态变量)
    * [3.静态函数](#3.静态函数)
    * [4.类的静态成员](#4.类的静态成员)
    * [5.类的静态函数](#5.类的静态函数)
* [C++和C的区别](#C++和C的区别)
* [C++中四种cast转换](#C++中四种cast转换)
    * [1.const_cast](#1.const_cast)
    * [2.static_cast](#2.static_cast)
    * [3.dynamic_cast](#3.dynamic_cast)
    * [4.reinterpret_cast](#4.reinterpret_cast)
    * [5.为何不用C的强制转换](#5.为何不用C的强制转换)
* [C/C++中指针和引用的区别](#C/C++中指针和引用的区别)
* 
* [C++中四种cast转换](#C++中四种cast转换)
    * [1.const_cast](#1.const_cast)
    * [2.static_cast](#2.static_cast)
    * [3.dynamic_cast](#3.dynamic_cast)
    * [4.reinterpret_cast](#4.reinterpret_cast)
    * [5.为何不用 C 的强制转换](#5.为何不用 C 的强制转换)
    * 
* <!-- GFM-TOC -->


# static关键字

## 1.全局静态变量

在全局变量前加上关键字 static，全局变量就定义成一个**全局静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被**自动初始化为 0**（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明**仅在本文件可见**，他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

## 2.局部静态变量

在局部变量之前加上关键字 static，局部变量就成为一个**局部静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为 0（自动对象的值是任意的，除非他被显式初始化）；
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是**仍然驻留在内存当中**，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

## 3.静态函数

在函数返回类型前加 static，函数就定义为**静态函数**。函数的定义和声明在默认情况下都是 extern 的，但静态函数**仅在本文件可见**，不能被其他文件所用。
函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同名函数引起冲突；
warning：在**头文件中声明非static 的全局函数**，在 **cpp 内声明static 的全局函数**，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；

## 4.类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员**，而不是某个对象的成员。对多个对象来说，静态数据成员**只存储一处**，供所有对象共用。

## 5.类的静态函数

静态成员函数和静态数据成员一样，它们都属于**类的静态成员**，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在**静态成员函数的实现中不能直接引用类中说明的非静态成员**，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);



# C++和C的区别

## 设计思想上

C++是**面向对象**的语言，而 C 是面向过程的结构化编程语言

## 语法上

C++具有**重载**、**继承**、**多态**三种特性；
C++相比 C，增加多许多类型安全的功能，比如强制类型转换；
C++支持**范式编程**，比如模板类、函数模板等。



# C++中四种cast转换

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

## 1.const_cast

用于将 const 变量转为非 const。

## 2.static_cast

```
static_cast< new_type >(old_type)
new_type为目标数据类型，old_type 为原始数据类型变量或者表达式。
```

用于各种隐式转换，比如非 const 转 const，void*转指针等, static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

**static_cast**相当于传统的C语言里的强制转换，用来强迫**隐式转换**非 const 转 const，void*转指针等，但**没有运行时类型检查来保证转换的安全性**。它主要有如下几种用法：

1. 用于类层次结构中**基类**和**派生类**之间指针或引用的转换。
   进行**向上**转换是**安全**的； 
   进行**向下**转换时，由于没有动态类型检查，所以是**不安全**的。 
2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 
3. 把空指针转换成目标类型的空指针。 
4. 把任何类型的表达式转换成void类型。 

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性

## 3.dynamic_cast

```
dynamic_cast< new_type >(old_type)
new_type为目标数据类型，old_type 为原始数据类型变量或者表达式。
```

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。要深入了解内部
转换的原理。
向上转换：指的是子类向基类的转换
向下转换：指的是基类向子类的转换
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

## 4.reinterpret_cast

几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用；

## 5.为何不用C的强制转换

C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。



# C/C++中指针和引用的区别

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象 的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而对引用的修改都会改变引用所指向的对象；
5. 可以有 const 指针，但是没有 const 引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
7. 指针可以有多级指针（**p），而引用至于一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。





































































































## 1. 并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

## 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

## 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 4. 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

# 基本功能

## 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

## 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

## 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

## 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

# 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div><br>

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :---: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |

# 大内核和微内核

## 1. 大内核

大内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

## 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>

# 中断分类

## 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

## 2. 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

## 3. 陷入

在用户程序中使用系统调用。






<div align="center"><img width="320px" src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/githubio/公众号二维码-2.png"></img></div>
