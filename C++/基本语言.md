<!-- GFM-TOC -->

* [static关键字](#static关键字)
  * [1.全局静态变量](#1.全局静态变量)
  * [2.局部静态变量](#2.局部静态变量)
  * [3.静态函数](#3.静态函数)
  * [4.类的静态成员](#4.类的静态成员)
  * [5.类的静态函数](#5.类的静态函数)
* [C++和C的区别](#C++和C的区别)
* [C++中四种cast转换](#C++中四种cast转换)
  * [1.const_cast](#1.const_cast)
  * [2.static_cast](#2.static_cast)
  * [3.dynamic_cast](#3.dynamic_cast)
  * [4.reinterpret_cast](#4.reinterpret_cast)
  * [5.为何不用C的强制转换](#5.为何不用C的强制转换)
* [C/C++中指针和引用的区别](#C/C++中指针和引用的区别)
* [C++智能指针](#C++智能指针)
  * [1.auto_ptr](#1.auto_ptr)
  * [2.unique_ptr](#2.unique_ptr)
  * [3.shared_ptr](#3.shared_ptr)
  * [4.weak_ptr](#4.weak_ptr)
* 
* 
* 
  * [1.const_cast](#1.const_cast)
  * [2.static_cast](#2.static_cast)
  * [3.dynamic_cast](#3.dynamic_cast)
  * [4.reinterpret_cast](#4.reinterpret_cast)
  * [5.为何不用 C 的强制转换](#5.为何不用 C 的强制转换)
* [C++中四种cast转换](#C++中四种cast转换)
  * [1.const_cast](#1.const_cast)
  * [2.static_cast](#2.static_cast)
  * [3.dynamic_cast](#3.dynamic_cast)
  * [4.reinterpret_cast](#4.reinterpret_cast)
  * [5.为何不用 C 的强制转换](#5.为何不用 C 的强制转换)
* [C++中四种cast转换](#C++中四种cast转换)
  * [1.const_cast](#1.const_cast)
  * [2.static_cast](#2.static_cast)
  * [3.dynamic_cast](#3.dynamic_cast)
  * [4.reinterpret_cast](#4.reinterpret_cast)
  * [5.为何不用 C 的强制转换](#5.为何不用 C 的强制转换)
  * 
* <!-- GFM-TOC -->


# static关键字

## 1.全局静态变量

在全局变量前加上关键字 static，全局变量就定义成一个**全局静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被**自动初始化为 0**（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明**仅在本文件可见**，他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

## 2.局部静态变量

在局部变量之前加上关键字 static，局部变量就成为一个**局部静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为 0（自动对象的值是任意的，除非他被显式初始化）；
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是**仍然驻留在内存当中**，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

## 3.静态函数

在函数返回类型前加 static，函数就定义为**静态函数**。函数的定义和声明在默认情况下都是 extern 的，但静态函数**仅在本文件可见**，不能被其他文件所用。
函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同名函数引起冲突；
warning：在**头文件中声明非static 的全局函数**，在 **cpp 内声明static 的全局函数**，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；

## 4.类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员**，而不是某个对象的成员。对多个对象来说，静态数据成员**只存储一处**，供所有对象共用。

## 5.类的静态函数

静态成员函数和静态数据成员一样，它们都属于**类的静态成员**，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在**静态成员函数的实现中不能直接引用类中说明的非静态成员**，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);



# C++和C的区别

## 设计思想上

C++是**面向对象**的语言，而 C 是面向过程的结构化编程语言

## 语法上

C++具有**重载**、**继承**、**多态**三种特性；
C++相比 C，增加多许多类型安全的功能，比如强制类型转换；
C++支持**范式编程**，比如模板类、函数模板等。



# C++中四种cast转换

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

## 1.const_cast

用于将 **const** 变量转为**非 const**。它也是四个强制类型转换运算符中**唯一**能够去除 const 属性的运算符。

## 2.static_cast

```c++
static_cast< new_type >(expression)
// new_type 为目标数据类型，expression 为原始数据类型变量或者表达式。
```

基本数据类型之间的转换，如int、float、char之间的互相转换；用于各种隐式转换，比如非 const 转 const，void*转指针等但**没有运行时类型检查来保证转换的安全性**。它主要有如下几种用法：

1. 用于类层次结构中**基类**和**派生类**之间指针或引用的转换。
   进行**向上**转换是**安全**的； 

   进行**向下**转换时，由于没有动态类型检查，所以是**不安全**的。因为 基类不包含派生类的成员变量，无法对派生类的成员变量赋值。

2. 用于基本数据类型之间的转换，如int、float、char之间的互相转换

3. 把空指针转换成**目标类型的空指针**。 

4. 把任何类型的表达式转**换成void类型**。 

注意：static_cast不能**去掉**expression的const、volatile、或者__unaligned属性。

```c++
char a = 'a'; int b = static_cast<char>(a);  //将char型数据转换成int型数据

const int g = 20;
int *h = static_cast<int*>(&g);   //编译错误，static_cast不能去掉g的const属性
```

```c++
class Base
{};
class Derived : public Base
{}

Base* pB = new Base();
if(Derived* pD = static_cast<Derived*>(pB))
{}  //下行转换是不安全的(坚决抵制这种方法)

Derived* pD = new Derived();
if(Base* pB = static_cast<Base*>(pD))
{}   //上行转换是安全的
```

## 3.dynamic_cast

```c++
dynamic_cast< new_type >(expression)
// new_type 为目标数据类型，expression 为原始数据类型变量或者表达式。
dynamic_cast< type* >(e)   //type必须是一个类类型且必须是一个有效的指针 
dynamic_cast< type& >(e)   //type必须是一个类类型且必须是一个左值 
dynamic_cast< type&& >(e)  //type必须是一个类类型且必须是一个右值
```

用于**动态类型转换**。只能用于**含有虚函数的类**，用于类层次间的**向上**和**向下**转化、类之间的**交叉转换**（cross cast）。只能转**指针**或**引用**。

在类层次间**向上**转换时，dynamic_cast和static_cast的效果是一样的；在进行**向下**转换时，dynamic_cast具有**类型检查**的功能，它通过判断在执行到该语句的时候，变量类型和要转换的**类型是否相同**来判断是否能够进行向下转换，如果是非法的对于转换目标是**指针**类型返回 NULL，对于引用抛std::bad_cast异常比static_cast更安全。

## 4.reinterpret_cast

几乎什么都可以转，比如将 int 转指针，执行的是**逐个比特复制**的操作。容易出问题，尽量少用。

## 5.为何不用C的强制转换

C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。



# C/C++中指针和引用的区别

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而对引用的修改都会改变引用所指向的对象；
5. 可以有 const 指针，但是没有 const 引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
7. 指针可以有多级指针（**p），而引用至于一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。



# C++智能指针

C++里面的四个智能指针: **auto_ptr**, **shared_ptr**, **weak_ptr**, **unique_ptr** 其中后三个是c++11 支持，并且第一个已经被 11 弃用。

为什么要使用智能指针：
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

## 1.auto_ptr

c++98 的方案，cpp11 已经抛弃。

```c++
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错.
```

此时不会报错，**p2 剥夺了 p1 的所有权**，但是当程序运行时访问 p1 将会报错。所以 auto_ptr存在潜在的内存崩溃问题。

## 2.unique_ptr

替换 auto_ptr。unique_ptr 实现**独占式拥有**或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如：以 new 创建对象后因为发生异常而忘记调用 delete)特别有用。还是上面那个例子：

```c++
unique_ptr<string> p3 (new string ("auto")); //#4
unique_ptr<string> p4； //#5
p4 = p3;  //此时会报错！！
```

编译器认为 p4=p3 非法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr更安全。另外unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

```c++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1; // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You")); // #2 allowed
```

其中#1 留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2 不会留下悬挂的 unique_ptr，因为它调用unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr 。
注：如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数 **std::move()**，让你能够将一个 unique_ptr 赋给另一个。例如：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

## 3.shared_ptr

shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使用**计数机制**来表明资源被几个指针共享。可以通过成员函数 use_count()来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用 release()时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
成员函数：

- **use_count** 返回引用计数的个数

- **unique** 返回是否是独占所有权( use_count 为 1)

- **swap** 交换两个 shared_ptr 对象(即交换所拥有的对象)

- **reset** 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

- **get** 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的。如：

  ```c++
  shared_ptr<int> sp(new int(1)); // sp 与 sp.get()是等价的
  ```

## 4.weak_ptr

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr 设计的目的是为**协助shared_ptr** 而引入的一种智能指针, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

weak_ptr 是用来**解决 shared_ptr 相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。

```c++
class B;
class A
{
	public:
	shared_ptr<B> pb_;
	~A()
	{
		cout<<"A delete\n";
	}
};
class B
{
	public:
	shared_ptr<A> pa_;
	~B()
	{
		cout<<"B delete\n";
	}
};
void fun()
{
	shared_ptr<B> pb(new B());
	shared_ptr<A> pa(new A());
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout<<pb.use_count()<<endl;
	cout<<pa.use_count()<<endl;
}
int main()
{
	fun();
	return 0;
}  
```

可以看到 fun 函数中 pa ，pb 之间互相引用，两个资源的引用计数为 2，当要跳出函数时，智能指针 pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为 1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为 weak_ptr 就可以了，我们把类 A 里面的 **shared_ptr pb**; 改为 **weak_ptr pb**; 运行结果如下，这样的话，资源 B 的引用开始就只有 1，当 pb 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为 0，A 得到释放。

注意的是我们不能通过 weak_ptr 直接访问对象的方法，比如 B 对象中有一个方法 print()，我们不能这样访问，pa->pb->print(); 英文 pb_是一个 weak_ptr，应该先把它转化为shared_ptr，如：

```c++
shared_ptr p = pa->pb_.lock(); 
p->print();
```



# 数组和指针

| 指针                                 | 数组                                 |
| ------------------------------------ | ------------------------------------ |
| 保存数据的地址                       | 保存数据                             |
| 指针的内容为为地址，从该地址访问数据 | 直接访问数据                         |
| 通常用于动态的数据结构               | 通常用于固定数目且数据类型相同的元素 |
| 通过 Malloc 分配内存，free 释放内存  | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名函数       | 自身即为数据名                       |




# 野指针是什么

野指针就是指向一个**已删除的对象**或者**未申请访问受限内存区域**的指针



















