<!-- GFM-TOC -->

* [static关键字](#static关键字)
    * [1.全局静态变量](#1.全局静态变量)
    * [2.局部静态变量](#2.局部静态变量)
    * [3.静态函数](#3.静态函数)
    * [4.类的静态成员](#4.类的静态成员)
    * [5.类的静态函数](#5.类的静态函数)
* [C++和C的区别](#C++和C的区别)
* [C++中四种cast转换](#C++中四种cast转换)
    * [1.const_cast](#1.const_cast)
    * [2.static_cast](#2.static_cast)
    * [3.dynamic_cast](#3.dynamic_cast)
    * [4.reinterpret_cast](#4.reinterpret_cast)
    * [5.为何不用C的强制转换](#5.为何不用C的强制转换)
* [C/C++中指针和引用的区别](#C/C++中指针和引用的区别)
* 
* [C++中四种cast转换](#C++中四种cast转换)
    * [1.const_cast](#1.const_cast)
    * [2.static_cast](#2.static_cast)
    * [3.dynamic_cast](#3.dynamic_cast)
    * [4.reinterpret_cast](#4.reinterpret_cast)
    * [5.为何不用 C 的强制转换](#5.为何不用 C 的强制转换)
    * 
* <!-- GFM-TOC -->


# static关键字

## 1.全局静态变量

在全局变量前加上关键字 static，全局变量就定义成一个**全局静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被**自动初始化为 0**（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明**仅在本文件可见**，他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

## 2.局部静态变量

在局部变量之前加上关键字 static，局部变量就成为一个**局部静态变量**。
内存中的位置：**静态存储区**，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为 0（自动对象的值是任意的，除非他被显式初始化）；
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是**仍然驻留在内存当中**，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

## 3.静态函数

在函数返回类型前加 static，函数就定义为**静态函数**。函数的定义和声明在默认情况下都是 extern 的，但静态函数**仅在本文件可见**，不能被其他文件所用。
函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同名函数引起冲突；
warning：在**头文件中声明非static 的全局函数**，在 **cpp 内声明static 的全局函数**，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；

## 4.类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员**，而不是某个对象的成员。对多个对象来说，静态数据成员**只存储一处**，供所有对象共用。

## 5.类的静态函数

静态成员函数和静态数据成员一样，它们都属于**类的静态成员**，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在**静态成员函数的实现中不能直接引用类中说明的非静态成员**，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);



# C++和C的区别

## 设计思想上

C++是**面向对象**的语言，而 C 是面向过程的结构化编程语言

## 语法上

C++具有**重载**、**继承**、**多态**三种特性；
C++相比 C，增加多许多类型安全的功能，比如强制类型转换；
C++支持**范式编程**，比如模板类、函数模板等。



# C++中四种cast转换

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

## 1.const_cast

用于将 const 变量转为非 const。

## 2.static_cast

```
static_cast< new_type >(old_type)
new_type为目标数据类型，old_type 为原始数据类型变量或者表达式。
```

用于各种隐式转换，比如非 const 转 const，void*转指针等, static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

**static_cast**相当于传统的C语言里的强制转换，用来强迫**隐式转换**非 const 转 const，void*转指针等，但**没有运行时类型检查来保证转换的安全性**。它主要有如下几种用法：

1. 用于类层次结构中**基类**和**派生类**之间指针或引用的转换。
   进行**向上**转换是**安全**的； 
   
   进行**向下**转换时，由于没有动态类型检查，所以是**不安全**的。因为 基类不包含派生类的成员变量，无法对派生类的成员变量赋值。
   
2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 

3. 把空指针转换成目标类型的空指针。 

4. 把任何类型的表达式转换成void类型。 

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性

## 3.dynamic_cast

```
dynamic_cast< new_type >(old_type)
new_type为目标数据类型，old_type 为原始数据类型变量或者表达式。
```

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。要深入了解内部
转换的原理。
向上转换：指的是子类向基类的转换
向下转换：指的是基类向子类的转换
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

## 4.reinterpret_cast

几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用；

## 5.为何不用C的强制转换

C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。



# C/C++中指针和引用的区别

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象 的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而对引用的修改都会改变引用所指向的对象；
5. 可以有 const 指针，但是没有 const 引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
7. 指针可以有多级指针（**p），而引用至于一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。



















